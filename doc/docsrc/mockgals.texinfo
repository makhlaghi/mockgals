\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename mockgals.info

@include ./docsrc/generalmacros.texi
@include ./docsrc/formath.texi

@settitle MockGals @value{VERSION}
@afourpaper

@dircategory Astronomy
@direntry
* mockgals: (MockGals).         Make mock galaxies and stars.
@end direntry

@c Use section titles in cross references, not node titles.
@xrefautomaticsectiontitle on

@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex pg cp

@c %**end of header







@copying
This manual is for MockGals (version @value{VERSION},
@value{UPDATED}), a program to make mock astronomical objects in a
FITS image and add the appropriate noise.

Copyright @copyright{} 2014 Mohammad Akhlaghi.
@email{akhlaghi@@astr.tohoku.ac.jp}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is available in @ref{GNU Free
Documentation License}.
@end quotation
@end copying





@titlepage
@title MockGals
@subtitle Make mock stars and galaxies in a FITS image with noise.
@subtitle Manual for MockGals version @value{VERSION}, @value{UPDATED}.
@author Mohammad Akhlaghi

@page
@vskip 0pt plus 1filll
@insertcopying

@page
@vskip 0pt plus 1filll
@quotation
Anticipations are a ground sufficiently firm for consent, for even if
men went mad all after the same fashion, they might agree one with
another well enough.
@author Francis Bacon, Novum Organum Scientiarum, 1620.
@end quotation

@end titlepage

@ifnottex
@node Top, About, (dir), (dir)
@top MockGals

MockGals is a tool to produce mock galaxies and stars based on an
input catalog, or randomly, into a FITS image, which is the standard
format to store astronomical data, of any given size. All paramters to
define mock galaxies and to define background noise are easily
configurable. We have tried to give a very complete overview of how to
install, understand and use MockGals version @value{VERSION}
(@value{UPDATED}) for your scientific research. We sincerely hope it
can be useful.

Like the program, this manual will be constantly upgraded, so there
might always be unwanted errors or parts of the text that can be
explained better. I will try to correct any that I find.

@ifhtml
To navigate easily in this webpage, you can use the @code{Next},
@code{Previous}, @code{Up} and @code{Contents} links in the top and
bottom of each page. @code{Next} and @code{Previous} will take you to
the next or previous topic in the same level, for example from chapter
1 to chapter 2 or vice versa. To go to the sections or subsections,
you have to click on the menu entries that are there when ever a
sub-component to a title is present.

To show the equations in some sections of this manual, we use the the
@url{http://www.mathjax.org/, MathJax}, JavaScript display
engine. Therefore to view the Math easily, you have to have JavaScript
enabled. If it is not enabled, you can still read the math if you are
familiar with writting equations in TeX: inline equations are marked
with @code{\(...\)} and equations that are positioned in the center of
a separate line for themselves (displayed mathematics) are marked
with @code{$$...$$}.
@end ifhtml

@ifinfo
This manual contains figures and equations, both of which cannot be
shown on in plain text or on the command line, In order to enable you
to follow the argument, we have these conventions for figures and
equations:
@itemize
@item
The location of the figures are given based on the position of the
source file. If you have not downloaded the full source, you can find
the figures in this address online: 
@url{http://astr.tohoku.ac.jp/~akhlaghi/mockgals/mockgals/mockgals-figures/}

@item
In general we have two types of equations, inline equations and
display equations. Inline equations are generally short and are placed
in between the lines of a paragraph. Display equations are generally
long and have a devoted line for themselves. In this manual inline
equations are marked with $...$ (for example $E=mc^2$) and display
equations are marked in a separate line with $$...$$, for example:

@center $$F=ma$$

@noindent
To write equations in ASCII characters we use the method of TeX, if
you are not familiar, you can learn here:
@url{http://en.wikibooks.org/wiki/LaTeX/Mathematics}.
@end itemize
@end ifinfo
@end ifnottex

@menu
* About::                       Why we wrote this and how to read it.
* Quick start::                 To get a fast start, have a look here.
* Concepts::                    The main methods and functions used.
* Installation::                How to install MockGals.
* Configuring::                 Explanation on how to tell MockGals what to do.
* Mock parameters::             The parameters that are input into MockGals.
* How it works::                Detailed explanation of the coding.
* GNU General Public License::  GNU GPLv3, Licence of MockGals.
* GNU Free Documentation License::  Licence of this manual.
* Manual Index::                Index, to find exact concepts.
@end menu


@contents

@ifplaintext
@noindent
---------------------------

@noindent
Copyright notice:
@insertcopying
@end ifplaintext















@node About, Quick start, Top, Top
@chapter About

To get started with MockGals please please see @ref{Quick start}.  The
following sections in this chapter are more general discussions.
In the first section we will give a short review of the way modern
science has become intertwined with software and how important it is
for scientists to have very good understanding of the software they
use.  After that your rights as the reader of this document and user of
MockGals are explained and in the end of this chapter we give a short
review of how this manual is available for your use and a short
summary of the manual.







@menu
* Good Science::                Critical/Objective science and its software.
* Your rights::                 Your rights as a user of MockGals.
* Manual formats::              How to make the best use of this manual.
* Conventions::                 The conventions used in writing this manual.
* Summary::                     A summary of all this manual.
@end menu

@node Good Science, Your rights, About, About
@section Objective/critical science and its software
@cindex Transparent software
@cindex Approximations in science
@cindex Simplifications in science
@cindex Software in Science
@cindex Science and software
History of science shows us that no interpretation, model or technique
(software) is perfect.  There are always inevitably unseen faults,
hidden assumptions, simplifications and approximations in all of our
constructs. It is precisely these that will ultimately allow future
generations to find and correct or solve them, thus advancing our
experimental and theoretical knowledge of the universe. Therefore, we
should be as explicit as possible about such approximations and
simplifications. Through keeping software free and transparent (with a
clearly written, detailed and up to date manual) for all scientists,
we can most accurately convey our experiences to users who can build
on those or find their shortcomings, hence facilitating the progress
of science.

With the progress of technology, scientific results are increasingly
becoming more and more dependent on hardware and software
techniques. While in the past, scientists would gather data and
process them individually to achieve an analysis, today scientits
mainly leave the first two steps to pre-written software libraries,
therefore distancing themselves from the pure observational data.

@cindex Anscombe, F.J
@quotation
Unfortunately, most persons who have recourse to a computer for
statistical analysis of data are not much interested either in
computer programming or in statistical method, being primarily
concerned with their own proper business. Hence the common use of
library programs and various statistical packages. Most of these
originated in the pre-visual era. The user is not showered with
graphical displays. He can get them only with trouble, cunning and a
fighting spirit. It's time that was changed.
@author F. J. Anscombe. The American Statistician, Vol. 27, No. 1. 1973
@end quotation

@cindex Good statistical analysis
@cindex Anscombe quartet
@cindex Obscure software
Anscombe argues that ``Good statistical analysis is not a purely
routine matter, and generally calls for more than one pass through the
computer''. He demonstrated how four data sets with widely different
shapes (when plotted) give nearly identical output from standard
regression techinques, see
@url{http://en.wikipedia.org/wiki/Anscombe%27s_quartet, Anscombe's
quartet}. Thus he showed how wrong it is to only rely on outputs of
standard methods to interpret the data. Although we have much better
graphic displays today, unfortuantely the general situation has not
changed too much from Anscombe's time.  Obscure software, either
closed source or with a bad manual, is certainly one of the main
culprits.  Most of the software packages available today for a
scientist are either closed source or have a bad, out-dated or not
clearly written manual.  Making an interested scientist think twice
before trying to understand the inner workings of a software.  Thus
the wide use of free and transparent software may be one step in a
larger scheme to save the sciences...

@cindex Karl Popper
@cindex Popper, Karl
@quotation
...from narrow specialization and from an obscurantist faith in the
expert's special skill and in his personal knowledge and authority; a
faith that so well fits our post-rationalistic and post critical age,
proudly dedicated to the destruction of the tradition of rational
philosophy and of rational thought its self.
@author Karl Popper. The logic of scientific discovery. 1959.
@end quotation

To reach this goal, namely to let the users of a software be able to
understand its intricate details at their will, a software has to be
accompanied by a good and up to date manual. The user of a software
cannot claim to understand how it works only based on the experience
they have gained by frequently using it. This kind of subjective
experience is prone to very serious mis-understandings about how it
really works. This kind of experience only helps in producing dogmas
and the above mentioned ``obscurationist faith in the expert's special
skill''.  

@cindex Black box
Unfortunately in the commonly used astronomical software packages at
least, most are either closed source or don't have a good manual. The
scientific results that are deduced from such software are thus not
objective, because in the former case scientists have to look at it as
a black box and trust its results on faith or their subjective
experience. In the latter, it is very hard to find enough time to
understand the programming of an open source project without a clearly
written and up to date manual explaining all the ideas behind the
major functions, data structures or objects.

It is certainly time consuming for the author of a software to make
such a manual. But if our greater common experience is considered,
that time, is a time well invested. Because through sharing of these
fundamental ideas and techniques, that define all our scientific
results, and keeping them open to criticism, we can make them more
robust and thus take better steps in our common goal to tackle the
riddles of nature. Also, through writing the manual, the programmer
gets to understand her/his own program and its strengths and
weaknesses much better, which can most of the time result in changes
in the program that will make it much more accurate and user friendly.
MockGals its self is an excellent example, while writing @ref{How it
works}, we recognized several inefficient processes that MockGals was
doing and corrected them. The result was that while the accuracy
remained unchanged, the CPU efficiency doubled (it done the same job
in half the time). 

@cindex Bjarne Stroustrup
@cindex Stroustrup, Bjarne
@cindex Ken Thomson
@cindex Thomson, Ken
@cindex user
@findex C++
Bjarne Stroustrup (creator of the C++ language) says: ``Without
understanding software, you are reduced to believing in magic''.  Ken
Thomson (the designer or the Unix operating system) says ``I abhor
a system designed for the ``user'' if that word is a coded pejorative
meaning ``stupid and unsophisticated''.'' No scientist would want to
be considered as ``stupid and unsophisticated'', so both these cases
naturally apply much more seriously to programs written for scientific
applications and as scientists we should be loyal to such principles
if we want to remain critical and be objective. 

All our data and models are produced, archived and processed using
hardware and software. If our aim in pursuing science is tackling the
riddles of nature, and not merely stacking published papers with our
names on them, we cannot and should not accept any result through
faith in the programmer who wrote that particular program(s) which
determines all our scientific results.





@node Your rights, Manual formats, Good Science, About
@section Your rights as a user of MockGals

@cindex Free software
MockGals is ``free software''; this means that everyone is free to use
it and free to redistribute it on certain conditions. MockGals is not
in the public domain; it is copyrighted and there are restrictions on
its distribution, but these restrictions are designed to permit
everything that a good cooperating citizen would want to do.  What is
not allowed is to try to prevent others from further sharing any
version of MockGals that they might get from you.

Specifically, we want to make sure that you have the right to give
away copies of the programs that relate to MockGals, that you receive
the source code or else can get it if you want it, that you can change these
programs or use pieces of them in new free programs, and that you know
you can do these things.

To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the MockGals related programs, you must give the recipients
all the rights that you have.  You must make sure that they, too,
receive or can get the source code.  And you must tell them their
rights.

Also, for our own protection, we must make certain that everyone finds
out that there is no warranty for the programs that relate to MockGals.
If these programs are modified by someone else and passed on, we want
their recipients to know that what they have is not what we distributed,
so that any problems introduced by others will not reflect on our
reputation.

The precise conditions of the licenses for the programs currently
being distributed that relate to MockGals are found in the General
Public license, see @ref{GNU General Public License} that accompany
them.  This manual is covered by the GNU Free Documentation License,
see @ref{GNU Free Documentation License}.

The paragraphs above, in this section, belong to the GNU Texinfo manual
and are not written by us! We have just changed the name ``Texinfo''
to ``MockGals'' because it and this manual are released under the same
licenses and it is beautifully written to inform you of your rights.





@node Manual formats, Conventions, Your rights, About
@section Manual Formats and reading recommendations
@pindex Emacs
This manual is available in plain text, HTML, Info, Docbook, PDF and
finally the Texinfo format. The last one is the basis for creating all
the other formats. As an initial introduction the PDF and HTML formats
might be easier to begin using MockGals, but if you would like to
understand the code while reading @ref{How it works}, it is much
easier to do so in the Info format. For example in Emacs, which is an
extensible, customizable text editor that is made for programming, you
can have one window on the code and another on the Info version of
this manual and follow the functions and explanations together.

@cindex Ubuntu
@cindex Fedora
@cindex Linux Mint
@cindex Debian
@cindex OpenSUSE
@cindex RedHat
@cindex RHEL
@cindex CentOS
@cindex Scientific Linux
@pindex info
@cindex info, learning
@cindex learning info
Info is a very convenient format particularly useful for software
documentation. We strongly recommend becoming familiar with it if you
are not already because it can significantly enhance your experience
in programming and in your GNU based operating systems user
experience.  Operating systems like Ubuntu, Fedora, Linux Mint,
Debian, OpenSUSE, Red Hat, CentOS or Scientific linux among many
others. Info is very trivial and made for reading manuals. It provides
facilities to navigate easily in long manuals. To learn more about it
in any GNU/linux terminal you can run: @command{$ info info}. It does
a fantastic job in explaining its self in practice interactively.

@cindex A4 paper size
@cindex Letter paper size
@cindex Convert to Letter paper size
By default, the PDF version of this manual is prepared in the A4 paper
size (21.0cm by 29.7cm). In case you prefer a letter size (8.5in by
11in), you can simply change it by following the steps below. You must
have Texinfo and @TeX{} installed on your system, for an explanation
on how to install them see @ref{Installation}.

@enumerate
@item
In the downloaded source directory (lets call it @file{SRC/}), open
the @file{SRC/doc/mockgals.texinfo} Texinfo source file of this
manual.

@item
Delete the line that says @code{@@afourpaper}. It is in the first few
lines of the file.

@item
run @code{$ ./run.sh} in that same directory, this will re-make all
the documenation formats.
@end enumerate





@node Conventions, Summary, Manual formats, About
@section Conventions
@itemize
@item
Commands to be input into the command line as normal user begin with
@command{$}. On the command line, before @command{$}, you will have
something like this: @command{[idname@@computername D]} where
@command{D} stands for the directory you are in, which is @command{~}
(your home directory) by default.

@cindex Super-user
@cindex root
@item
Commands that to be input as root (or super-user), start with
@command{#}. Note that you need the root password in order to execute
the latter commands. 

To switch to the root user (or super-user) you can simply run
@command{$ su}. You will be prompted with a password and if it is
correct you will gain super-user privileges.  After switching to root,
the @command{idname}, see previous list item, changes to
@command{root}.

@item
The @command{commands}, @option{-options}, @file{file_names},
@code{programming_codes} and keyboard @kbd{keys} in this manual are
written as they are written here. Be careful not to include text
punctuation marks that might follow them.

@item
When mentioning the order of menus to choose on a graphical user
interface application, we will list them like this example:
@clicksequence{File @click{} Save as}, which means to first click on
the ``File'' menu and then choose ``Save As'' in the list that opens.
@end itemize





@node Summary,  , Conventions, About
@section Summary
@ref{Quick start} is a quick start to get you going with MockGals.  It
explains the most frequently used inputs and outputs of mockgals so
you can get started. Once you have used it in some simple situations
and get a good understanding of what MockGals has to offer, you can go
on with the rest of the manual.

In @ref{Concepts} the main functions and methods that are used are
introduced generally. @ref{Installation} introduces how to install all
the requirements of MockGals and its self. @ref{Configuring} explains
the command-line options that you can use to define the general
settings of MockGals. @ref{Mock parameters} explains how you can
define the parameters for each profile.





















@node Quick start, Concepts, About, Top
@chapter A Quick start

@cindex Randomly positioned galaxies
@cindex FITS
Once MockGals is installed system wide, @pxref{Installation}, you can
simply run @command{$mockgals -nme}, any where and, 45 mock galaxies
and 5 stars will be randomly positioned in a @mymath{200 \times 200}
FITS image, which is the standard format to store astronomical
data. These options are not necessary for the production of the final
noised FITS image and explained below. @ref{quickpreview} shows one
such random example.  The central positions of some of these random
profiles is intentionally placed outside of the actual image range in
order to be more realistic. MockGals ignores objects that are
completely out of the image, but even if a small fraction of their
area (within the defined truncation radius) falls within the image,
that part will be included.

@float Figure, quickpreview
@center@image{./mockgals-figures/s1_noconv,5cm,,./mockgals-figures/s1_noconv.jpg,.jpg}@image{./mockgals-figures/s1_conv, 5cm,,./mockgals-figures/s1_conv.jpg,.jpg}@image{./mockgals-figures/s1_noised, 5cm,,./mockgals-figures/s1_noised.jpg,.jpg}

@caption{Three extentions of the output of @command{$mockgals
-nm}. Left: 45 galaxies and 5 stars with no convolution. Middle, The
same image after convolution. Right: After adding noise.}
@end float

After MockGals has finished, two files are added to the directory you
ran it in: @file{mock.fits} and @file{mockinfo.txt}. The first is
generally a multi-extension FITS file and the second is a text file
listing the properties of all the profiles that are positioned in this
image.

@findex -m
@findex -n
@findex -e
To view the full list of options, see @ref{Configuring} where all the
options are explained. The two options used here, namely @option{-m}
and @option{-n}, will output the desired image prior to convolution
(left in @ref{quickpreview}) and the convolved image prior to adding
noise (middle in @ref{quickpreview}) respectively. @option{-e} will
print out all the steps MockGals takes in making the image. So if you
don't pass these options along, you will only get the right image
of @ref{quickpreview}, with out any reporting.





@menu
* InputOutput::                 Input and output into MockGals.
* Viewing multiextension FITS files::  How to easily view a multi-extention FITS.
@end menu




@node InputOutput, Viewing multiextension FITS files, Quick start, Quick start
@section Setting input and output

@findex -x
@findex -y
@cindex Galaxy list
@cindex List of galaxies
Normally, you wouldn't want MockGals to give you 45 random galaxies
and 5 stars! You want to give it a list of galaxies with known
properties so MockGals can make those galaxies for you. The output
image size is determined on the command line by the @option{-x} and
@option{-y} options. The first sets the horizontal width and the
second the height of the output image, see @ref{Configuring} for more
information.

@cindex ASCII table
@findex -i
@cindex Ouput table
@cindex Input table
MockGals reads the properties you want for the galaxies through an
ASCII table, a simple ASCII text file, where columns are separated by
white space or @kbd{TAB}. An example is the @file{mockinfo.txt} table
that was created above. The file name of the table you have created
with the profile properties can be specified with the @option{-i}
option. If it doesn't exist, MockGals will make the default 50 random
profiles (5 stars and 45 galaxies) as it did when you ran
@command{$mockgals -nme}. If you run this command again, one more time,
it is going to make exactly the same image it made the first time,
this is because if no input is given, it is going to read the profile
properties from @file{mockinfo.txt}, that it made after its first run,
and make an exact duplicate.

@cindex Output FITS
By default the output FITS file is named @file{mock.fits} you can also
ask for a different output file name through the option
@option{-o}. When reading for input, MockGals does not read the
columns that specify the total magnitude of the object. It will make
the profiles and then fill this column by its self. 




@node Viewing multiextension FITS files,  , InputOutput, Quick start
@section Viewing multi-extension FITS files

@cindex Multiextention FITS
@pindex ds9
@cindex Opening multiextention FITS
If you run @command{$mockgals} with the @option{-m} or @option{-n}
options, the output will be a multi-extention FITS file. Lets assume
you use @url{http://ds9.si.edu/, SAOImage ds9} (from now on, we'll
call it ds9) to view FITS images, see @ref{Installing ds9}. If you
ordinarily open a multi-extension FITS file with ds9, by double
clicking on it or running @command{$ds9 foo.fits} for example, ds9
will only show you the first extension. To be able to switch between
the extensions you have to follow these menus in the ds9 window:
@clicksequence{File@click{}Open Other@click{}Open Multi Ext Cube} and
then choose the Multi extension FITS file in your computer's file
structure.

@findex ds9 -mecube
The method above is a little tedious to do every time you want view a
multi-extension FITS file. Fortunately ds9 also provides options that
you can add to it. One of those options is @option{-mecube} which
opens a FITS image as a multi-extension data cube, so on the command
line if you run @command{$ds9 -mecube foo.fits}, you can switch
between all the extensions that @file{foo.fits} might have. If
@file{foo.fits} only consists of one extension, then ds9 will open as
usual. 

It is really convenient if you set ds9 to always run with the
@option{-mecube} option on your graphical display. On a GNU/Linux
operating system, you can do this by following the following steps.
Right click on a FITS file and choose
@clicksequence{Properties@click{}Open With@click{}Add} button. A list
of applications will show up, ds9 might already be present in the
list, but don't choose it because it will run with no options. Below
the list is an option ``Use a custom command''. Click on it and write
the following command: @command{ds9 -mecube} in the box and click
``Add''. Then finally choose the command you just added as the default
and click the ``Close'' button.











@node Concepts, Installation, Quick start, Top
@chapter Basic concepts

@cindex Validating theory
@cindex Active experimenter
@cindex Passive observer
@cindex Uncertainty in observations.

Once the internal consistencies of theories have been verified, the
only method scientists have to test their theories is gathering data
from scientific experiments. For example in Physics and Chemistry
where we are an active element in the experiment, or through
observations, like in Astronomy where we are only passive observers to
the events that occur naturally. There is always an element of
uncertainty in our observations. We either don't completely understand
the nature of the subject we are observing or we think we understand
the nature fine enough but the data is diluted with a lot of noise, or
both, which is unfortunately the case most of the time.

@cindex Calibrate analysis tools
In order to be able to tackle these two problems, before actually
doing any form of analysis on real data, a scientist first has to
calibrate the data analysis tools with a set of mock subjects where
s/he knows the exact nature of the data without noise. We also have to
simulate noise and any other instrumental defects that are bundled in
with the data and add them to the mock data to try to simulate a real
observation. The data analysis techniques that are applied to the real
data can then be first tested on the mock data to see how accurately
our method measures the properties we want it to measure in known
objects. Of course, whether our model actually resembles the data is
an issue we have to have ascertained before this step.

@cindex Faint objects, importance
This is the fundamental raison d'@^etre of MockGals. In astronomy,
faint objects or the fainter parts of bright objects are the most
curious aspects of the universe, simply because they are extremely
faint! They are either nearby faint objects or very distant bright
objects. Both are the most curious objects in Astronomy, and
understanding their nature is the primary reason behind investing so
much in larger ground and space based telescopes.

@cindex Purpose of mock galaxies
So any tool we use to observe such real galaxies, has to be first
tested with mock galaxies, because identifying a diffuse faint galaxy
in a large noise is extremely hard and prone to very serious
systematic bias if we don't test our detection methods accurately and
understand the systematic biases they inevitably have.

@cindex Parametric fitting
Mock galaxies can also be used to fit known parametric models to the
observed galaxies, for example suppose we have a real galaxy image and
we have a radial functional profile, for example the S@'ersic profile,
see @ref{Galaxies},  and we want to see what values of the free
parameters of the S@'ersic profile fit best with the observed galaxy,
or more generally, if that functional radial profile is suitable or
not for that particular object. In this case, we can make various mock
2D S@'ersic profiles with various properties that have the observable
properties of our desired object and check to see which one best
resembles the real galaxy. This feature will be a future addition to
MockGals. The infra-structure for this capability is already in place,
we just have to find the time to add this capability.

@cindex 2D surface
@cindex 3D volume
Currently MockGals makes mock profiles on a 2D surface, but the
infra-structure is there to make the profiles on a 3D volume and find
a real projection of a real 3D object. This is also a future upgrade
we plan to apply.



@menu
* Object profiles::             Various functional profiles used in MockGals.
* Adding Noise::                Various noise sources in Astronomical images.
* Why C::                       Why we chose the C langauge to write MockGals.
* Intro References::            References to the papers mentioned here.
@end menu

@node Object profiles, Adding Noise, Concepts, Concepts
@section Object profiles

MockGals has been written for extra galactic studies, so the only
astronomical objects it can produce are stars and galaxies. In this
section we review how an ellipse with a certain functional form is
created and in the following sections the functional radial profiles
used for the PSF, stars and galaxies are explained separately.

@menu
* Defining an ellipse::         Defining an ellipse in 2D.
* PSF::                         Radial profiles for the PSF.
* Stars::                       Making mock star profiles.
* Galaxies::                    Radial profiles for galaxies.
* Central profile pixels::      Dealing with central regions of sharp profiles.
@end menu

@node Defining an ellipse, PSF, Object profiles, Object profiles
@subsection Defining an ellipse

@cindex Ellipse
@cindex Ellipse major axis
@cindex Ellipse minor axis
@cindex Major axis, ellipse
@cindex Minor axis, ellipse
@cindex Position angle
The PSF, see @ref{PSF}, and galaxy radial profiles are generally
defined on an ellipse so in this section we will first review how an
ellipse can be defined on a 2D surface. Labeling the major axis of an
ellipse @mymath{a}, and its minor axis with @mymath{b}, the axis ratio
is defined as: @mymath{q\equiv b/a}. The major axis of an ellipse can
be aligned in any direction, we therefore define the angle of the
major axis to the horizontal axis of the image as position angle of
the ellipse and in this manual, we show it with @mymath{\theta}.

@cindex Radial distance
@cindex Radial function
@cindex Function, radial
Our aim is to put a radial profile of any functional form @mymath{f(r)}
over an ellipse. Lets define the radial distance @mymath{r_{el}} as the
distance on the major axis to the center of the ellipse which is
located at @mymath{x_c} and @mymath{y_c}. We want to find the elliptical
distance of a point located at @mymath{(i,j)}, in the image coordiate
system, from the center of the ellipse. First we rotate the coordinate
system by @mymath{\theta} to get the new rotated coordiantes of that point
@mymath{(i_r,j_r)}:

@dispmath{i_r(i,j)=(i_c-i)\cos(\theta)+(j_c-j)\sin(\theta)}
@dispmath{j_r(i,j)=(j_c-j)\cos(\theta)-(i_c-i)\sin(\theta)}

@noindent The elliptical distance of a point located at @mymath{(i,j)} 
can now be defined as: @mymath{r_{el}^2=\sqrt{i_r^2+j_r^2/q^2} }. To
place the radial profiles explained below over an ellipse, we simply
calculate @mymath{f(r_{el}(i,j))} based on the functional radial profile
desired.





@node PSF, Stars, Defining an ellipse, Object profiles
@subsection Point Spread function

@cindex PSF
@cindex Point spread function
@cindex Atmospheric spread
@cindex Diffraction limit
Assume we have a ``point'' source. When we take an image of it, it
will ``spread'' over an area. To quantify that spread, we can define a
a ``function''. This is how we define the point spread function or the
PSF of the image. This ``spread'' can have various causes, for example
in ground based astronomy, due to the atmosphere. In practice we can
never surpass the ``spread'' due to the diffraction of our lens
aperture. Vairous other effects can also be quantified through a PSF,
for example, the simple fact that we are sampling in a discrete space,
namely the pixels, also produces a very small ``spread'' in the image
we take.

@cindex PSF image, odd sides
@cindex Odd sides of PSF image
Since we want the total flux of an object to remain unchanged after
convolution by the PSF, in both cases, it is important that the sum of
all the pixels of the PSF be unity. The image also has to have an odd
number of pixels on its sides so one pixel can be defined as the
center. In MockGals, the PSF can be set by the two methods explained
below.

@table @asis

@cindex Parametric PSF
@cindex PSF, parametric
@cindex Full width at half maximum
@cindex FWHM
@item Parametric functions
A known mathematical function is used to make the PSF. In this case,
only the paramaters to define the functions are necessary and MockGals
will make a PSF based on the given parameters for each function. In
both cases, the center of the profile has to be exactly in the middle
of the central pixel of the PSF (which is automatically done by
MockGals). When talking about the PSF, usually, the full width at half
maximum or FWHM is used as a scale of the width of the PSF.

@table @cite
@cindex Gaussian function
@item Gaussian
In the older papers, and to a lesser extent even today, some
researchers use the 2D gaussian function to approximate the PSF of
ground based images. In its most general form, a Gaussian function can
be written as:

@dispmath{f(r)=a \exp \left( -(x-\mu)^2 \over 2\sigma^2 \right)+d}

Since the center of the profile is pre-defined, @mymath{\mu} and
@mymath{d} are constrained. @mymath{a} can also be found because we want
the function to be normalized. So the only important parameter for
MockGals is the @mymath{\sigma}. In the Gaussian function we have this
relation between the FWHM and @mymath{\sigma}:

@cindex Gaussian FWHM
@dispmath{\rm{FWHM}_g=2\sqrt{2\ln{2}}\sigma \approx 2.35482\sigma}.

@cindex Moffat function
@item Moffat
The Gaussian profile is much sharper than the images taken from stars
on photographic plates or CCDs. Therefore in 1969, Moffat proposed
this functional form for the image of stars:

@dispmath{f(r)=a \left[ 1+\left( r\over \alpha \right)^2 \right]^{-\beta}}

@cindex Moffat @mymath{\beta}
Again, @mymath{a} is constrained by the normalization, therefore two
paramters define the shape of the Moffat function: @mymath{\alpha} and
@mymath{\beta}. The radial parameter is @mymath{\alpha} which is related
to the FWHM by

@cindex Moffat FWHM
@dispmath{\rm{FWHM}_m=2\alpha\sqrt{2^{1/\beta}-1})}

@noindent
Comparing with the PSF predicted from atmospheric turbulence theory
with a Moffat function, Trujillo et al. 2001 claim that @mymath{\beta}
should be 4.765. They also show how the Moffat PSF contains the
Gaussian PSF as a limiting case when @mymath{\beta\to\infty}.

@end table

@cindex PSF, input FITS
@cindex Input FITS as PSF
@item An input FITS image
An input image can also be specified to be used as a PSF. See
@option{-f} in @ref{Options with arguments}.
@end table


@cindex Gaussian/Moffat comparison
@cindex Comparison Gaussian/Moffat
@cindex Moffat/Gaussian comparison
In @ref{MoffatGaussianComp}, you can see a comparison of the Gaussian
and Moffat profiles. All profiles have the same FWHM of 5 units. While
the Gaussian is only dependent on the FWHM, the Moffat function is
also dependant on @mymath{\beta}. Therefore we have shown the Moffat
function for 4 @mymath{\beta} values.

@float Figure, MoffatGaussianComp
@center@image{./mockgals-figures/S3_MoffatGaussianComp,15cm,,./mockgals-figures/s3_MoffatGaussianComp.pdf,}
@caption{Comparison between the Gaussian and Moffat functions with
various @mymath{\beta} values. All 5 profiles have the same FWHM of 5
units.}
@end float

The results of comparing these functions can be summarized as:

@itemize
@item 
Within the FWHM, the functions don't have significant differences.
@item
The Gaussian function is much sharper than the Moffat functions, even
when @mymath{\beta} is large.
@item
For a fixed FWHM, as @mymath{\beta} increases, the Moffat function
becomes sharper.
@end itemize




@node Stars, Galaxies, PSF, Object profiles
@subsection Star Profiles

@cindex Stars, profile
@cindex Profile, stars
@cindex Point source
In MockGals, we generally consider stars to be a point source. This is
usually the case for extra galactic studies, were nearby stars are
also in the field. Since a star is only a point source, we assume that
it only fills one pixel prior to convolution. Four such examples can
be seen in @ref{quickpreview} by comparing the left (prior to
convolution) and the middle (after convolution) images. Therefore the
final shape of a star can be considered as the shape of the PSF used
to make the mock images.

@cindex Star image as PSF
Infact, exactly for this reason, in astronomical images the light
profiles of stars are one of the best methods to understand the shape
of the PSF and a very large fraction of scientific research is
preformed by assuming the shapes of stars to be the PSF of the image.




 
@node Galaxies, Central profile pixels, Stars, Object profiles
@subsection Galaxies

@cindex Profile, galaxies
@cindex Galaxy profiles
@cindex S@'ersic profile
@cindex Generalized de Vaucouleurs profile
@cindex de Vaucouleurs profile
Today, most practitioners agree that galaxy profiles can be modeled
with one or a few generalized de Vaucouleur's (or S@'ersic) profiles.

@dispmath{I(r) = I_e exp \left ( -b_n \left[ \left( r \over r_e \right)^{1/n} -1 \right] \right )}

@cindex Effective radius
@cindex Radius effective
@cindex Total brightness
@cindex S@'ersic index
This profile depends on the effective radius (@mymath{r_e}) which is
defined as the radius which contains half of the total brightness of
the object. The total brightness is defined as the integration of the
profile to infinity. @mymath{I_e} is the surface brightness at the
effective radius.  The S@'ersic index @mymath{n} is used to define the
concentration of the profile within @mymath{r_e} and @mymath{b_n} is a
constant dependent on @mymath{n}. MacArthur et al. 2003 show that for
@mymath{n>0.35}, @mymath{b_n} can be accurately approximated using
this equation:

@dispmath{b_n=2n - {1\over 3} + {4\over 405n} + {46\over 25515n^2} + {131\over 1148175n^3}-{2194697\over 30690717750n^4}}

@cindex S@'ersic index comparison
Below, see @ref{SersicComp}, 5 example S@'ersic profiles with various
@mymath{n} values are shown. All the profiles have been divided by their
central value in order to compare their behavior especially in the
central parts of the profile

@float Figure, SersicComp
@center@image{./mockgals-figures/S3_SersicComp,15cm,,./mockgals-figures/S3_SersicComp.pdf,}
@caption{S@'ersic profiles with various @mymath{n} values, all profiles have the same @mymath{r_e=5} units.}
@end float

@cindex G@'erard de Vaucouleurs
@cindex de Vaucouleurs, G@'rard
@cindex S@'ersic J. L.
@cindex J. L. S@'ersic
G@'erard de Vaucouleurs (1918-1995) was first to show in 1948 that
this function best fits the galaxy light profiles, with the only
difference that he held @mymath{n} fixed to a value of 4. 20 years
later in 1968, J. L. S@'ersic showed that @mymath{n} can have a
variety of values and does not necessarily have to be 4.





@node Central profile pixels,  , Galaxies, Object profiles
@subsection Central profile pixels
@cindex Central profile pixel
@cindex Random points for central pixel
@cindex Gradient over pixel
@cindex Pixel, gradient of flux
@cindex Integrate over pixel
@cindex Pixel, integrate flux
@cindex PCV
@cindex Pixel center value
A pixel is the ultimate level of accuracy we have to gather data, we
call this sampling. But the mathematical profiles that we define have
infinite accuracy. Generally, the variation in the profiles over the
area of one pixel is not too significant. If so, we can simply use the
elliptical radius of the center of the pixel and assign that as the
final value of the pixel. Lets call this value pixel center value
(PCV).

Unfortunately though, as you saw in @ref{SersicComp}, some of the
galaxy profiles become very sharp as we approach their center. This
sharpness increases with smaller effective radius and larger S@'ersic
values. This sharp change in the radial profile will produce a strong
gradient over the central few pixels of the object. Thus rendering PCV
extremely inaccruate. 

The first method that comes to mind for solving this problem is
integration, we can integrate the functional form of the profile over
the pixel area in a 2D integration process, as explained
@ref{Making central}. In MockGals we use the
Gauss-Kronrod-Patterson abscissae as provided in the GNU scientific
library. This is certainly far more accurate than PCV but
unfortunately numerical integration techniques also have their
limitations and when such sharp profiles are needed they become
extremely inaccurate.

The most accurate method to try to sample a continues profile on a
discrete space (sampling) is by choosing a large number of random
points within the boundaries of the pixel and taking their average
value. This is also, generally speaking, what happens in practice with
the photons on the CCD. The problem is this: how many random points
should be chosen? In order to find out, lets look at an extremely
sharp S@'ersic profile with @mymath{\theta=22}, @mymath{q=0.3},
@mymath{n=10} and @mymath{r_e=1} pixel. Although such a sharp profile
is very rarely found in nature, we have to be prepared. For simplicity
we will position it exactly in the center of a pixel.

Let @mymath{I_r} represent the flux from the average of a large number
of randomly positioned points and @mymath{I_i} to be the value after
integrating the profile over the pixel area. We define the relative
difference as: @mymath{|I_r-I_i|/I_r}. We then tested this difference
with @mymath{10^3}, @mymath{10^4}, @mymath{10^5}, @mymath{10^6},
@mymath{10^7} and @mymath{10^8} random points over the pixel area. The
differneces were @mymath{580701}, @mymath{525220}, @mymath{500575},
@mymath{511167}, @mymath{509204} and @mymath{508288}
respectively. Since this profile is so sharp, only the central pixel
has such a huge difference, for the rest of the pixels, the
differences are smaller than 0.01.  

If the center of the profile was off of the center of a pixel, these
values would change and be shared by the neighboring pixels.  The
differences between random points and integration is extremely large,
but we see that the difference between @mymath{10^4} random points and
@mymath{10^8} random points is only about @mymath{3} percent, while
the CPU burden, or operation time, is 10,000 times less! Therefore it
seems reasonable to choose @mymath{10^4} random points to test
integration.

In MockGals, the building of the profile begins from its central pixel
and continues outwards, see @ref{Making central}. It would be
perfectly ideal if we could use the @mymath{10^4} or even larger
number of random points, to fill all the pixels, to be more accurate
and also to be closer to what really happens. But unfortunately, such
a process would be extremely time and CPU consuming. But in order to
not loose too much accuracy, in MockGals, we build the profile using
all the three methods explained above. 

We begin building a profile from the pixel in the image that is
closest to the center. First we try @mymath{10^4} random points, if
the difference (as defined above) with integration is tollerable,
MockGals will stop using random points and only use integration. As we
go to farther regions in the profile, the difference between
integration and using PCV will also go below a tolerance level and
beyond that point we only use PCV.

@cindex Comparison, integration over pixels
@cindex Integration over pixels, comparison
@cindex Tolerance, integration
@cindex Integration tolerance
@ref{pixintegq1} and @ref{pixintegq25} show the difference between
integration and the central pixel value for the first
@mymath{\sim2000} pixels in a mock S@'ersic profile with various axis
ratios (@mymath{q}). Let @mymath{I_i} be the pixel value if
integration is preformed over it and @mymath{I_c} represent the
profile value at the pixel center. The tolerance level that the user
can set is defined as: @mymath{T=|I_i-I_c|/I_i}. The marked pixels in
@ref{pixintegq1} show the pixels that integration will be applied to
if the user sets @mymath{T=10^{-2}}. Integration will stop at the
first pixel that gives a smaller tolerance.

@float Figure, pixintegq1
@center@image{./mockgals-figures/s3_integq1,15cm,,./mockgals-figures/s3_integq1.pdf,.png}

@caption{Difference between integrating over the pixel area
(@mymath{I_i}) and using the central pixel value (@mymath{I_c}). Each
point shows one pixel and is colored based on the logarithm of the
fraction of the total object flux that is in that pixel. The profile
used here is a S@'ersic profile with @mymath{n=4}, @mymath{r_e=3}
pixels, @mymath{\theta=60^\circ} and @mymath{q=1}. The The solid
horizontal line shows where the fractional difference of the profile
becomes 1/100. The pixels with an asterisk are those that integration
will be applied to in practice. }
@end float


@float Figure, pixintegq25
@center@image{./mockgals-figures/s3_integq25,15cm,,./mockgals-figures/s3_integq25.pdf,.png}

@caption{Same as @ref{pixintegq1} but with @mymath{q=0.25}. See
@ref{integpixfill} for a demonstration on how the pixels to integrate
over are found for this profile.}
@end float





@node Adding Noise, Why C, Object profiles, Concepts
@section Noise
@cindex Image noise
@cindex Noise 
Deep astronomical images, like those used in extra galactic studies
seriously suffer from noise in the data. Generally speaking, the
sources of noise in an astronomical image are:

@table @asis
@cindex Counting noise, error
@cindex Noise, counting
@cindex Error, counting
@cindex Poisson noise
@cindex Noise, Poisson
@item Photon counting noise
Thanks to the very accurate electronics used in today's CCDs, this
type of noise is the main cause of concern for extra galactic studies.
It can generally be associate with the counting error that is known to
have a Poissonian distribution. The Poisson distribution is about
counting. But counting is a discrete operation with only positive
values, for examle we can't count @mymath{3.2} or @mymath{-2} of
anything. We only count @mymath{0}, @mymath{1}, @mymath{2}, @mymath{3}
and so on. Therefore the Poisson distribution is also a discrete
distribution, only applying to whole positive integers.

Lets assume that we know the mean value of counting something, in this
case electrons that are produced by photons in the CCD, is
@mymath{\lambda}.  Lets take @mymath{k} to represent the result of
counting in one particular time we attempt to count. The probability
denstity function of @mymath{k} can be written as:

@cindex Poisson distribution
@dispmath{f(k)={\lambda^k \over k!} e^{-\lambda},\quad k\in \{0, 1, 2,
3, \dots \}}

@cindex Skewed poisson distribution
Because the Poisson distribution is only applicable to positive
values, it is by nature very skewed when @mymath{\lambda} is near
zero. One qualitative way to imagine it is that there simply aren't
enough integers smaller than @mymath{\lambda}, than there are larger
integers. Therefore to accomodate all possibilities, it has to be
skewed when @mymath{\lambda} is small. 

But as @mymath{\lambda} becomes larger and larger, the distribution
becomes more and more symmetric. One very useful property of the
Poisson distribution is that the mean value is also its variance.
When @mymath{\lambda} is very large, say @mymath{\lambda>1000}, then
the normal (Gaussian) distribution, see @ref{PSF}, is an excellent
approximation of the poisson distribution with mean
@mymath{\mu=\lambda} and standard deviation
@mymath{\sigma=\sqrt{\lambda}}. 

We see that the variance or dispersion of the distribution depends on
the mean value, and when it is large we can approximate it with a
Gaussian that only has one free parameter (@mymath{\mu=\lambda} and
@mymath{\sigma=\sqrt{\lambda}}) instead of two that it originally
has. 

@cindex Background flux
@cindex Sky flux
The astronomical objects after convolution with the PSF of the
instrument, lie above a certain background flux. This background flux
is defined to be the average flux of a region in the image that has
absolutely no objects. The physical origin of this background value is
the brightness of the atmosphere. It is thus an ideal definition,
because in practice, we never know what lies deep in the noise far
lower than our detection criteria. Take another look at the noised
image of @ref{quickpreview}, you see that a relatively large number of
the mock objects have been fully buried in the noise. These undetected
objects will bias our background measurement to slightly larger
values. We therefore define the sky value to be the average of the
undetected regions in the image, so in an ideal case where we have
successfully detected all the objects, the sky value and background
value are the same.

As we go to longer wavelengths, the background value becomes more
significant and also varies over a wide image field. Such variations
are not currently implemented in MockGals, but will be in the
future. In a mock image, we have the luxuary of setting the background
value.

In each pixel of the canvas of pixels we have made to build the
galaxies, we might have contributions from various sources. Also the
image has been convolved prior to adding noise. Lets name this flux of
the convolved sum of possibly overlapping objects, @mymath{I_{nn}}.
@mymath{nn} representing ``no noise''. For now, lets assume the
background is constant and represented by @mymath{B}. In practice the
background values are larger than 10,000 counts. Then the flux after
adding noise is a radom value taken from a Gaussian distribution with
@mymath{\mu=B+I_{nn}} and @mymath{\sigma=\sqrt{B+I_{nn}}}.

@cindex Readout noise
@cindex CCD readout noise
@item Readout noise
This is noise that is produced by the electronics in the CCD that
attempt to read the amount of flux that was recorded. In deep
extra-galactic studies this kind of noise is not a significant source
of the final noise in the image. Currently MockGals does not simulate
this type of noise, but it is planned to be simulated in future
verisons.

@cindex Dark current noise
@cindex Noise, dark current
@item Shot noise on dark current
While taking images with a CCD, a dark current is fed to the pixels,
the variation of the value of this dark current over the pixels, also
adds to the final image noise. Although, for deep observations, like
those used for extra galactic studies, this is not the dominant source
of noise. Currently MockGals does not simulate this source of noise, but
it is planned to be added.
@end table

In MockGals noise is added to the image after convolving the produced
profiles with the PSF. 

@cindex Signal to noise
@cindex S/N
@cindex SN
Now that the sources of noise have been discussed we can define the
signal-to-noise (S/N or SN are also used). Since noise is defined on a
per-pixel basis, S/N is also defined on a per-pixel basis. Lets assume
the object has a total signal of @mymath{T} and an area @mymath{A}
pixels. Then the average flux of the object per pixel is defined as:
@mymath{a=T/A}. 

The noise term is defined as the RMS of all noise sources. Currenly
MockGals only makes photon counting noise, which can be quantified
with the square root of the total flux in a pixel as discussed above.
Since the background flux (@mymath{B}) dominates in all the pixels, we
just consider noise to be @mymath{\sqrt{B}}, therefore, the signal to
noise that you can set for a profile can be written as:

@dispmath{\rm{S/N}={a \over \sqrt{B}}}

Note that the average flux of a profile seriously depends on the
profile sharpness, so two S@'ersic profiles with all parameters equal
except the S@'ersic index will have very different SN values.



@node Why C, Intro References, Adding Noise, Concepts
@section Why C programming language?
@findex C
@findex C++
@cindex Object oriented paradigm
@cindex Programming abstraction
@cindex Abstraction, programming
Currently the programming language that is most commonly used in
scientific applications is the C++ language, not plain C. One of the
main reasons behind this choice is that through the Object Oriented
programming pradigm, the C++ language offers a much higher level of
abstraction.

But we have chosen the C programming language to write MockGals. The
reasons can be summarized with simplicity and speed. Both are
extremely important in a scientific software. A simple comparison of
the main books of the two langauges can act as a guide. The C
programming language book is only 286 pages and covers a very good
fraction of the language, it has also remained unchanged from
1988. The most recent C++ programming language book on the other hand
has 1366 pages and its fourth edition came out in 2013! As discussed
in @ref{Good Science}, it is very important for other scientists to be
able to readily read the code of a program at their will with minimum
requirements.

In C++, inheriting objects and their internal functions make the code
very easy to write for the programmer who is deeply invested in those
objects and understands all their relations well. But it
simultaneously makes reading the program for a first time reader
extremely hard, since before understanding the methods, they have to
invest a lot of time in understanding those objects and their
relations. But in C, if you only stick to simple structures, as we
have here, all the inputs and outputs to functions can be given as the
basic language types for example @code{int}s or @code{float}s and
their pointers to define arrays. So when an outside reader is only
interested in one part of the program, that part is all they have to
understand.

@cindex Low level programming
@cindex Programming, low level
Being a very low level (closer to the hardware) language, C also
allows for much more closer relation to the actual data we have in our
disposal, rather than the illusion of high-level abstractions that the
higher level languages provide. The
@url{http://www.gnu.org/prep/standards/, GNU coding standards} also
encourage the use of C over all other languages when generality of
usage and ``high speed'' is desired.

@node Intro References,  , Why C, Concepts
@section References

@noindent
de Vaucouleurs, G. (1948). ``Recherches sur les nebuleuses
extragalactiques''. In: Journal des Observateurs 31, p. 113.

@noindent
MacArthur, L. A., S. Courteau, and J. A. Holtzman (2003). ``Structure of
Disk-dominated Galaxies. I. Bulge/Disk Param- eters, Simulations, and
Secular Evolution''. In: ApJ 582, pp. 689---722.

@noindent
Moffat, A. F. J. (1969). ``A Theoretical Investigation of Focal
Stellar Images in the Photographic Emulsion and Application to
Photographic Photometry''. In: A&A 3, p. 455.

@noindent
Sersic, J. L. (1968). Atlas de galaxias australes.

@noindent
Trujillo, I., J. A. L. Aguerri, J. Cepa, and C. M. Gutierrez
(2001). ``The effects of seeing on S@'ersic profiles - II. The Moffat
PSF''. In: MNRAS 328, pp. 977---985.













@node Installation, Configuring, Concepts, Top
@chapter Installation

@cindex Requirements of MockGals
@cindex MockGals requirements
To install MockGals, there are three requirements which are all very
easy to setup on your GNU/Linux system. Here is a short list:

@itemize
@cindex GNU scientific library
@cindex GSL
@item
GNU scientific library, @url{http://www.gnu.org/software/gsl/, GSL},
which is mainly used to generate random numbers (for noise mainly) and
integration over the surface of pixels.

@item 
@cindex FFTW
@cindex Fasterst fourier transform in the west
Fastest Fourier Transform in the West, @url{http://www.fftw.org/,
FFTW}, which is used for convoling the actual profiles of the stars
and galaxies with the PSF.

@item 
@cindex CFITSIO
@url{http://heasarc.gsfc.nasa.gov/fitsio/fitsio.html, CFITSIO}, which
is the C library to create and manipulate FITS images.

@item 
@pindex ds9
@url{http://ds9.si.edu/, SAOImage DS9} which is not required for MockGals to
work! It is only a tool to view FITS images.
@end itemize

@cindex Scientific Linux
@cindex RHEL
@cindex Fedora
@cindex CentOS
@cindex Installing from source
@cindex Souce code, installing
@cindex GNU/Linux operating system
@cindex Operating system, GNU/Linux
So far we have only tested the installation of MockGals on a
Scientific Linux (SL) 6.5 machine. SL is a distribution of Linux based
on the Red Hat enterprise linux (RHEL). RHEL is also the base for
other common operating systems like Fedora and CentOS, so there
shouldn't be much difference. But since the explanations below are all
based on compiling from source, the explanations below should
generally be applicable on any
@url{http://en.wikipedia.org/wiki/Linux_distribution, GNU/Linux based
operating system}.

@menu
* Requirements::                How to install the required software
* MockGals Install::            Installing MockGals
@end menu





@node Requirements, MockGals Install, Installation, Installation
@section Installing requirements
@cindex un-compress 
@cindex Download source
@cindex Source download
In GNU/Linux operating systems, installing most programs from source
is very easy. Generally, the following commands have to be run in
sequence. Lets call the compressed file you download from the
software's webpage @file{downloaded.tar.gz}. Lets suppose that after
uncompressing, first command below, you get @file{untared_dir}.

@cindex System-wide installation
@example
$ tar zxvf downloaded.tar.gz
$ cd untared_dir
$ ./configure
$ make
$ su 
# make install
# exit
@end example

@noindent
Note that the second last command has to be run as root or superuser,
see @ref{Conventions}. That is why the third last command is
@command{$su}, which is short for ``switch user''. It will prompt you
with a request to provide the root password when no user name is
provided. Since you want to be able to use the libraries of these
three packages anywhere in your file system, it is best that you do
install them system wide by going through all the steps above. The
last command simply disables the root privileges and returns you back
to your own user ID. It is best to avoid remaining root for a long
time, because you might accidentally do something very harmful!

The sequence above, unchanged, is good for installing GSL. But CFITSIO
and FFTW need a slight modification in the third line. ds9 doesn't use
this sequence at all, it is available as already compiled from the
webpage.  To install CFITSIO and FFTW, you just have to add the
following flags (those that start with a @command{--}) after the
@command{$ ./configure} command. FFTW is simpler, so we'll start with
that:

@example
$ ./configure --enable-threads --enable-float
@end example

@noindent
For CFITSIO it should be run with these options:

@example
$ ./configure --enable-sse2 --prefix=/usr/local --enable-reentrant 
@end example

@cindex 32bit CPU
@cindex 64bit CPU
@cindex Multithread
@noindent
The first flag (for CFITSIO) is for increasing the reading and writing
speed and only works for a 64 bit systems. If you are on a 32 bit
system (not likely if your computer is less than 5 years old), don't
include it. The second one says where to put the final compiled
libraries, the given value is the standard place to put them. The last
one is if you want to access the fits files in a multithread manner.

@cindex Environment variables
@cindex Include directory
Both GSL and CFITSIO install their libraries in @file{/usr/local/}
which is the default directory for user installed programs. To inform
the GNU compiler collection, GCC which compiles MockGals, to look into
this directory, put these lines in your @file{~/.bashrc} file:

@example
export PATH = /usr/local/bin:$PATH
export LD_LIBRARY_PATH = /usr/local/lib:$LD_LIBRARY_PATH
export INCLUDE = /usr/local/include:$INCLUDE
@end example

You can edit @file{~/.bashrc} through the following commands:

@example
$ cd ~
$ gedit .bashrc
@end example

Once you have added the lines, you can simply save the changes and
close gedit.



@menu
* Installing ds9::              How to install SAOImage ds9
@end menu

@node Installing ds9,  , Requirements, Requirements
@subsection Installing SAOImage ds9
@cindex ds9
@cindex ds9, install
@cindex Instaling ds9
@cindex Graphic user interface
@cindex GUI
@cindex FITS viewer
@cindex View FITS
From the webpage ``SAOImage DS9 is an astronomical imaging and data
visualization application.'' ds9 is actually a very useful, simple
and easy Graphical User Interface (GUI) application for you to view
the fits images and do simple operations on them. 

@itemize
@item
@url{http://ds9.si.edu/site/Download.html,Download} the compressed
    binary file based on your operating system.  
@item
Unpack it with @command{$ tar zxvf [filename]}

@item
Copy the ds9 file to a system wide location (as root): @command{# mv
ds9 /usr/local/bin}.
@end itemize

By typing @command{$ ds9} any where in the command line you can begin
using it, you can also set your GNU/Linux Graphic user interface to
open any FITS file with ds9, we recommend to define it to open any
FITS image as a multiextension FITS image, see @ref{Viewing
multiextension FITS files} for an explanation on how to do that.

@cindex ds9, XPA error
@cindex XPA error, ds9
XPA is the ``X Public Access'' mechanism, its a messaging system in
DS9 that allows e.g. host scripts to load images or control the
display. After running ds9, if you get an error regarding XPA you can
put this line in @file{~/.bashrc} file, see @ref{Requirements}:
@example
export XPA_METHOD=local
@end example

To stop this command when you run ds9 from the Graphic User Interface,
follow the above procedures on @file{~/.profile} also, if you don't
already have that file, don't worry, the second command will create
it. But have in mind that you need to log out and log-in again for
this change to take effect.





@node MockGals Install,  , Requirements, Installation
@section Installing MockGals
@cindex MockGals source code
@cindex Source code, MockGals
The source code for MockGals is avilable
@url{https://github.com/makhlaghi/mockgals, on Github}. As with any
program that is available there, you have two options to download it.

@itemize
@cindex MockGals Github download
@cindex Github download MockGals
@item 
In Github's webpage, find the ``Download ZIP'' button on the right
side of the screen and Download the zip file. This will download
@file{mockgals-master.zip} to your computer (probably in your
@file{Downloads} directory). You can then un-compress the file by
runnnig @command{$ unzip mockgals-master.zip}. This will create the
directory @command{mockgals-master} in that directory. You can change
your directory with @command{$ cd mockgals-master}.

@cindex Github clone MockGals
@cindex Clone MockGals
@item
Alternatively, you can simply clone the whole repository with the
following command in any directory. ``Cloning'' is used in Git to
refer to downloading the whole version control history of the
repository along with the actual files necessary to install and run
it. A directory named @file{mockgals} will be created and you can
enter it with @command{$ cd mockgals}.

@example
$ git clone https://github.com/makhlaghi/mockgals.git
@end example

@end itemize

@cindex Make MockGals
@cindex MockGals, @command{make}
@cindex MockGals, compile
@cindex MockGals, install
@cindex Install MockGals
@cindex Compile MockGals
The number of requirements for MockGals is currently not too
much. Therefore we haven't set up the @command{$./configure} (from
@url{http://www.gnu.org/software/autoconf/, GNU autoconf}) installing
script like the three required programs. Therefore, which ever method
you used to download the source code, once you are in the directory,
you can simply run @command{$ make} and @command{# make install},
don't forget that the second has to be run as root, see
@ref{Conventions}. The installation script, copies the compiled
MockGals file into your @file{/usr/local/bin/} folder. You can then
call MockGals from anywhere in your system.




















@node Configuring, Mock parameters, Installation, Top
@chapter Configuring MockGals
@cindex Configuring MockGals
@cindex MockGals, configuring
@cindex Options in MockGals
@cindex MockGals, options
The options to configure MockGals can generally be classified as two
groups. A first group of options are those that are generally applied
to all the objects or those that relate to the FITS image that acts as
our canvas to build the mock galaxies on. A second set are options to
define each particular profile you want to make. The first set of
options are discussed here and the second set that are different for
each profile are explained in @ref{Mock parameters}.

Currently, the only way you can configure MockGals and ask it to do
various actions is through command line options. MockGals is
compatible with the
@url{http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html,
POSIX recommendations for command line arguments}. A summary of the
points are as follows:

@itemize
@cindex Hyphen delimiter
@item
Arguments are options if they begin with a hyphen delimiter
(@option{-}).

@cindex Multiple options
@cindex Options, multiple
@item
Multiple options may follow a hyphen delimiter in a single token if
the options do not take arguments, see @ref{Options with no
arguments}. Thus, @option{-abc} is equivalent to @option{-a -b -c}.

@item
Certain options require an argument, see @ref{Options with arguments}.

@item
An option and its argument may or may not appear as separate
tokens. (In other words, the whitespace separating them is optional.)
Thus, @option{-o foo} and @option{-ofoo} are equivalent.

@cindex Options, termination
@cindex Terminating options list
@cindex Finishing options
@item
The argument @option{--} terminates all options; any following arguments are treated as non-option arguments, even if they begin with a hyphen.

@cindex Options, ordering
@cindex Order of options
@cindex Recalling options
@cindex Options, recall
@item
Options may be supplied in any order, or appear multiple times. In
MockGals, for those options with arguments, this will ignore all
previous values assigned to that option.
@end itemize

MockGals has three types of options. Those that don't actually run
MockGals, those that don't require arguments and those that do. Below
you can see an explanation for each type. The second two types of
options have pre-defined default values set for them when MockGals
begins. Therefore you only need to call MockGals with an option, if
you want to change its default value.

If you do not supply any options or arguments to MockGals, it will
make 45 random galaxy profiles and 5 random stars positioned in a
square fits image of side 200 pixels. This was actually used in
@ref{Quick start}, where we only added three ON/OFF options. Try
removing those options to see the output.

@menu
* Informative options::         Options that don't run MockGals.
* Options with no arguments::   On/Off options, don't need arguments.
* Options with arguments::      Options that require arguments.
@end menu




@node Informative options, Options with no arguments, Configuring, Configuring
@section Informative options
@cindex Informative options
@cindex Options, informative
Sometimes you don't actually want to run MockGals, you just want to
know what version it is or you want to see a list of its options and
their default values and you don't feel like finding this manual to
browse it and find this section! The options here are made exactly 
with this purpose in mind.

If you supply any other options along with these options, they will be
totally ineffective and MockGals will abort after doing what these
options ask it to do.

@table @option
@findex -h
@cindex Help, list all options
@cindex List available options
@item -h
Running MockGals with this option will print the full list of options
available to you along with a short explanation and the default value
of each option.  The type of argument (string, integer or float) is
also specified to guide you in the values to assign to each option.

@findex -v
@cindex Version, print
@cindex Print version
@cindex Copyright, print
@cindex Print copyright
@item -v
Print the version and copyright  information for MockGals. Here is how
this looks for its first release.

@example
MockGals 0.1
============
Make mock stars and galaxies in a FITS image.

Copyright (C) 2014  Mohammad Akhlaghi
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to
modify and redistribute it under the
GNU Public License v3 or later.
@end example


@end table





@node Options with no arguments, Options with arguments, Informative options, Configuring
@section Options with no arguments
@cindex On/Off options
@cindex Options, On/off
Some of the configurations that can define MockGals behavior can be
thought of as ON/OFF options. You don't need to give it any value, you
just turn the switch ON or OFF. These options are listed below.

By default all these options are switched OFF unless you call them.

@table @option
@findex -e
@cindex Verbose
@cindex Options, verbose
@cindex MockGals, verbose
@item -e
Verbose mode. If this option is called (is switched on), MockGals will
report every step it takes in making the mock image. 

@findex -p
@cindex View PSF used
@cindex Used PSF, view
@cindex PSF, view used
@item -p
View the PSF. This is useful if you have asked MockGals to make a
functional PSF and you want to see how the PSF its self looks. If this
option is called, as soon as MockGals makes the PSF, it will save it
into @file{psf.fits}.

@findex -P
@cindex Only view PSF
@cindex View PSF, only
@cindex PSF, view only
@item -P
Only view the PSF, don't make mock galaxies. Sometimes you just want a
certain functional PSF and you don't want to create mock
galaxies. This option is made for such circumstances. If this option
is called, @option{-p} will be turned on, so there is no need to call
that option too. You just have to set your desired PSF parameters:
@option{-u} (function), @option{-a} (FWHM), @option{-b} (Moffat
@mymath{\beta}) and @option{-j} (truncation radius), see @ref{Options
with arguments} for a detailed discussion on these options..

@findex -m
@cindex Save unconvolved image
@cindex Unconvolved image, save
@item -m
Save the unconvolved mock image as an extention of the output FITS
image. If this option is activated, MockGals will save a copy of the
image before it gets convolved with the PSF. This image will be saved
as an extention to the output file. So by switching between different
extentions, you can see how convolution and noise have affected the
otherwise perfect initial image. As an example, please see the left
image of @ref{quickpreview}.

@findex -n
@cindex Convolved image, save
@cindex Save convolved image
@cindex Save image prior to convolution
@cindex Save no noised image
@cindex No noise image, save
@item -n
Save the convolved mock image as an extention of the output FITS
image.  If this option is activated, the image is saved right before
noise is added. See the middle image in @ref{quickpreview}. 

@end table





@node Options with arguments,  , Options with no arguments, Configuring
@section Options with arguments
@cindex Options with arguments
Some of the options require arguments. If you call them but don't
supply any arguments, MockGals will complain and abort. A list of them
can be seen below.

In this list, after each option the terms @option{INTEGER},
@option{FLOAT} or @option{FILENAME} can be seen, these terms show the
type of argument that each gets. If floating point value is given
instead of an integer, only its integer section will be used. In other
cases supplying the wrong type or argument to an option is not defined 
and might result in unexpected outcomes.

@table @option
@findex -x
@cindex Width of output in pixels
@cindex Output, width in pixels
@cindex Output, horizontal axis size
@cindex Horizontal axis, output size
@item -x INTEGER
The argument to this option will be the number of pixels in the
horizontal axis of the output image as viewed in ds9. The input to
this option has to be as positive (@mymath{>0}) integer. The default 
value for this option is 200.

@findex -y
@cindex Height of output in pixels
@cindex Output, height in pixels
@cindex Output, vertical axis size
@cindex Vertical axis, output size
@item -y INTEGER
Similar to @option{-x} but for the vertical axis of the output
image. The default value is 200.

@findex -i
@cindex Option, input table
@cindex Input table 
@cindex Idetifying input table
@item -i FILENAME
This is the name of the input ASCII text file. It can have any number
of comments (lines begining with @code{#}). It has to be space
separated table that is composed of @value{INPUTTABLENUMCOLS}
columns. The default file name is @file{mockinfo.txt}. For a very
detailed analysis of this file, please see @ref{Mock parameters}.

@findex -o
@cindex Options, output FITS
@cindex Output FITS name
@cindex Name of output FITS
@item -o FILENAME
The name of the output FITS image. Default is @file{mock.fits}.

@findex -s
@cindex Background value
@cindex Sky value
@cindex Options, background 
@cindex Noise, setting background value
@item -s FLOAT
The Background value. The main effect of this value is on the noise,
because the background noise standard deviation is the square root of
this value summed with the object pixel values. A larger argument to
this option will result in more significant noise. Default is 10000
counts or electrons.

@findex -z
@cindex Zeropoint magnitude
@cindex Magnitude, zero point
@item -z FLOAT
The zero point magnitude. One of the outputs for each profile is its
total magnitude. Practically, this is the paramter you can use to
calibrate your values with realistic values. Default is 26.00.

@findex -t
@cindex Options, truncation radius
@cindex Truncation radius 
@item -t FLOAT
The mock profiles do not extend to infinity! With this option you can
set the radial extent of the profile to be made. By default it is set
to 5.0. For each type of profile, this value will determine where to
stop building the profile.
@table @asis
@item S@'ersic
The argument to this option will be multiplied by the effective radius
(@mymath{r_e}) of the profile, see @ref{Galaxies}.

@item Gaussian
The argument to this function will be multiplied by
@mymath{\sigma}. For a Gaussian the input radial parameter is the
FWHM, MockGals converts that to @mymath{\sigma}, see @ref{PSF}.

@item Moffat
Half of the FWHM is multiplied to the argument of this function to set
a limit to the Moffat profile, see @ref{PSF}.
@end table

@findex -I
@cindex Tolerance level
@cindex Threshold, breaking
@item -I FLOAT
This is the tolerance level discussed in @ref{Central profile
pixels}. The first time the relative difference of a more accurate
method (first random points, then integration) with a less accurate
method (first integration, then the central pixel value) becomes
smaller than this tolerance, the more accurate method is abandoned.

@findex -f
@cindex Save PSF used option
@cindex PSF used, save
@cindex Options, save PSF
@item -f FILENAME
In case a given FITS image is to be used as the PSF of the image, its
file name has to be specified with this option. The FITS image has to
have sides that are odd numbers. It doesn't matter if the sum of its
pixel values are unity or not, if they aren't MockGals will multiply
all the pixels by the inverse of the sum so that it does become unity.
If a file is specified, @option{-u}, @option{-a} and @option{-b} will
be ignored.

@findex -u
@cindex PSF, functional form
@cindex Paramteric PSF option
@cindex Options, PSF functional form
@item -u INTEGER
Determine the functional form of a PSF. Any value other than the two
shown below will be changed to the default value which is 1 (Moffat
function).
@enumerate
@item
Moffat function.

@item
Gaussian function.
@end enumerate

@findex -a
@cindex PSF FWHM option
@cindex Options, PSF FWHM
@item -a FLOAT
PSF FWHM in pixels. Default value is 3 pixels.

@findex -b
@cindex Options, Moffat @mymath{\beta}
@cindex Moffat options, @mymath{\beta}.
@item -b FLOAT
Moffat function's @mymath{\beta}, see @ref{PSF}. In case a Gaussian is
asked for, this value is ignored. Default is 4.765 as discussed in
@ref{PSF}.

@findex -j
@cindex PSF truncation 
@cindex Truncation, PSF
@item -j FLOAT
PSF truncation radius. The argument to this option will determine the
size of the PSF. The PSF will only extend until the radius becomes
larger than half of the FWHM (or HWHM) multiplied to the argument of
this option. Note that currently all the PSFs produced by MockGals are
completely circular.

@findex -g
@cindex Histogram
@cindex Options, histogram
@cindex Image histogram
@item -g INTEGER
For Histogram. If the argument to this function is zero, no histogram
will be calculated. If it is any positive value, the positive value
will be set as the number of bins of a histogram. A negative value
will abort, default is 0.

@findex -c
@cindex Histogram minimum
@item -c FLOAT
For Histogram. Minimum histogram value, default: -250.

@item -d FLOAT
@cindex Histogram maximum
For Histogram. Maximum histogram value, default: 700.

@end table














@node Mock parameters, How it works, Configuring, Top
@chapter Mock parameters
@cindex Input table
@cindex ASCII input table
The parameters of the profiles you want to build into a FITS image are
fed to it through a table that is saved as an ASCII text file. MockGals
uses the argument to the @command{-i} option to identify that file, see
@ref{Options with arguments}.

@cindex Columns, input table
@cindex White space, input table
The input ASCII text file has to be composed of columns of data (only
numerical), separated by any number of @kbd{SPACE} or @kbd{TAB}
characters. In total it has to have @value{INPUTTABLENUMCOLS} columns
which are explained below. If it has a different number of columns,
MockGals will complain. Each row in the text file shows the
corresponding properties of a different object, with the total number
of uncommented rows, being the total number of profiles that will be
made, if they overlap with the image within their truncation radius of
course. In general, an input table can contain objects that are far
too distant from the region of the image size, such object will be
totally ignored.

After running the only output for each profile that MockGals can
provide is the total flux of the profile, it will be saved in one of
the columns in the input table and so, the file that is given as an
input will also be the text output of MockGals. So this file will
serve both as input and output.

@menu
* Input table comments::        Treatment of comments in the input ASCII file.
* Input table columns::         How each column is interpreted in MockGals.
@end menu

@node Input table comments, Input table columns, Mock parameters, Mock parameters
@section Comments in the input table.
@cindex Input table comments
@cindex Comments in input table
Any line in the input ASCII file that starts with a @code{#} will be
considered as a comment and ignored in the production of mock
galaxies. You can use such lines to add information for your own
personal usage or you can add the @code{#} at the start of each row
identifying an object so that MockGals does not build that particular
object.

In case the input file already has comments, they will all be stacked
on the top of the output, before the output table and MockGals will
not add any comments its self. On the other hand, if you don't supply
any comments, a set of comments will be printed on the output that
will explain the columns and some of the settings. An example of such
comments can be seen below after asking MockGals to build randomly
generated galaxies, see @ref{Quick start}.

@example
# Properties of 50 mock profiles.
# The sky valued is assumed to be: 10000.00
# The zeropoint magnitude is: 26.00
# Truncation at 5.00 * radial parameter
# 
# 0: ID.
# 1: 0: Sersic, 1: Moffat, 2: Gaussian, 3: Point.
# 2: X position (FITS definition).
# 3: Y position (FITS definition).
# 4: Sersic re or Moffat FWHM.
# 5: Sersic n or Moffat beta.
# 6: Position angle, degrees.
# 7: Axis ratio.
# 8: Signal to noise: (average profile flux-sky)/sqrt(sky).
# 9: Total magnitude.
@end example

@cindex Column counting
@noindent
You might have noticed that the column counting start from zero in the
output, this is because most programming languages start counting from
zero and this form of numbering the columns will be easier for the
user to use this data.

The number of galaxies, the sky value and truncation radius would
normally be set by the user in @ref{Options with arguments}, whatever
their value, they will be shown here. The values currently shown are
the default values.





@node Input table columns,  , Input table comments, Mock parameters
@section Columns of the input table.
As mentioned above, the input table has to have
@value{INPUTTABLENUMCOLS} columns. In this section we will review how
each column is interpreted by MockGals. Below is an example showing the
properties of 5 random profiles (two stars, three galaxies).

@example
4  3  22.37    48.96   18.80  0.71  14.71   0.41   300.0000  14.81
5  3  153.53   188.00  5.19   2.74  83.81   0.71   110.0000  15.90     
6  0  211.09   60.79   15.20  3.45  304.98  0.85   0.008390  14.21     
7  0  25.20    27.38   16.16  2.89  264.86  0.57   0.001480  16.40     
8  0  40.24    206.19  18.45  6.55  11.48   0.57   0.003102  15.31  
@end example

In the table below, each column is explained with the column counting
beginging from zero. Counting the columns is intentionally started
from zero to fit the way most programming languages count (starting
from zero).

@table @code
@item COLUMN 0
@cindex Input table, profile ID
@cindex Profile ID, input table
Your identifier for each profile. You can set an ID for each profile
in this column. MockGals completely ignores what is in this column,
the identifier you choose for a galaxy is a purely subjective matter!
Therefore, if you don't need IDs for your mock galaxies, you can just
set all the values in this column to the same value, for example
@code{0}, it makes no difference for MockGals!

Currently MockGals only reads numbers in the table, so after mockgals
finishes, if your IDs have non-numeric characters in them (for example
alphabetical characters), it will put a @code{-9999} in place of that
ID. This will be corrected in future updates to keep the same
alphabetic ID you had set.

@cindex Profile function, input table
@cindex Input table, profile function
@item COLUMN 1
The functional type of profile, see @ref{Object profiles}. In general,
you can set a profile value from any of the following functions:
S@'ersic, Moffat or Gaussian or Point. The codes for these three are
respectively 0, 1, 2, 3. Point is used to show a star where only one
pixel will be filled.

@cindex x axis profile position
@cindex horizontal axis profile position
@cindex Input table, axis 0 profile position
@item COLUMN 2
The position of the center of the profile along the first axis of the
FITS image which is the horizontal axis when viewed in ds9. This value
can be any floating point number such as larger than the image
boundary or a negative value. Any profile that does not overlap with
the image within its truncation radius will be ignored. The fractional
value is very important for sharper profiles, see @ref{Galaxies}.

Note that in the FITS standard, the middle of the first pixel in both
axes (which is the bottom left pixel when viewed in ds0) is considered
to have coordinates @code{(1,1)}. So for example the point
@code{(1.51,1)} will be in the pixel positioned on the second column
and first row of the FITS image, see @ref{C and FITS arrays} for a
more detailed discussion.

@cindex y axis profile position
@cindex vertical axis profile position
@cindex Input table, axis 1 profile position
@item COLUMN 3
Same as @code{COLUMN 2}, but for the vertical axis.

@cindex Setting profile radial paramter
@cindex Profile radial parameter, setting
@cindex Input table, profile radial parameter
@item COLUMN 4
Radial parameter of profile. Depending on the profile, this value
determines the radial paramter. In all cases the units are pixels.

@itemize
@item
Sersic: The effective radius (@mymath{r_e}).
@item
Moffat & Gaussian: The FWHM.
@item
Point: Ignored.
@end itemize

@cindex Profile sharpness parameter, set
@cindex Input table, profile sharpness
@cindex S@'ersic index
@item COLUMN 5
Sharpness parameter of the profile. This value will only be used for
the S@'ersic and Moffat functions that require a second paramter to determine their sharpness, see @ref{Object profiles}.

@itemize
@item 
S@'ersic: The S@'ersic index (@mymath{n})
@item
Moffat: @mymath{\beta}.
@item
Gaussian & Point: Ignored.
@end itemize

@cindex Input table, position angle
@cindex Position angle set
@item COLUMN 6
The position angle of the profile, see @ref{Defining an
ellipse}. Ignored for Point profiles.

@cindex Axis ratio, set
@cindex Input table, axis ratio
@item COLUMN 7
The axis ratio of the profile, see @ref{Defining an ellipse}. Ignored
for Point profiles.

@cindex Input table SN
@cindex Signal to noise, set
@item COLUMN 8
The total signal to noise (SN) of the profile. SN is defined as the
average flux in the profile (its total flux divided by its area within
the truncation radius) divided by the standard deviation of the
noise.

@cindex Total profile flux
@item COLUMN 9
The total flux in the profile. This column is filled in by MockGals,
it can be filled with any value on the input file, but after MockGals
finishes, this column is filled up.

@end table

@cindex ATTAAVV
In MockGals, we use the
@url{https://github.com/makhlaghi/attaavv,ATTAAVV} to read an ASCII
file to a C array and write a C array to an ASCII file. ATTAAVV is
distributed under GPL v3+ and can easily be incorporated into any
program.


















@node How it works, GNU General Public License, Mock parameters, Top
@chapter How mockgals works
This chapter is for those readers who are interested in knowing how
MockGals works. As discussed in @ref{Good Science}, we believe it is
extremely important for you to be able to easily understand the
details of the code without needing to invest a lot of time. We are
not shy of the mistakes we might have made or the bad methods we might
have chosen to do a certain task.

In fact the reason behind writing this chapter is precisely to
showcase the bare truth behind MockGals, to make you feel comfortable
with looking through the code so you can find such mistakes or crude
methods and hopefully inform us, or even better, join us in making it
a good free and transparent tool for every Astronomer to use and learn
from. Exposing the most intricate details is how we believe we can
solve any unseen problems.

@cindex MockGals, coding style
@cindex Coding style, MockGals
We have tried to be as loyal as possible to the
@url{http://www.gnu.org/prep/standards/,GNU Coding standards} in
writing MockGals. This will hopefully help in understanding the coding
style easily. 

@findex MG/
@findex SRC/
Lets assume that you have downloaded and unpacked or cloned MockGals,
see @ref{MockGals Install} in the @file{MG/} directory. In this
chapter all the files and folders will be discussed in relation to
this directory. For the sake of simplicity, we will also choose a
short name @file{SRC/} for the @file{MG/src/} directory.

This chapter of the manual will be the part that undergoes the most
change, therefore it can never be considered as a complete reference,
it can only be viewed as a simple explanations of the functions in
English and not in C.

@menu
* Reading method::              Our recommendation on how to read this chapter.
* Program flow::                Explanation on the flow and functions in MockGals.
@end menu





@node Reading method, Program flow, How it works, How it works
@section How to read this chapter
In order to be able to follow this chapter, it is easiest if you open
the code and the Info version of this manual in Emacs, each with its
own ``window'' in a wide ``frame'', so you can see both this
explanation and the code side by side. This will allow you to make
changes and see the changes immediately with the Emacs compile
command: @kbd{M-x compile} (and on subsequent calls, @kbd{M-x
recompile}). 

@cindex MockGals, change and compile
In case you want to compile the code and see the results
simultaneously, remove the @code{#} from @code{# ./mockgals -mne} in
@file{./MG/Makefile} so MockGals will be called to run as soon as the
compilation finishes, without requiring any inputs from you! This will
speed things up for you! You can change the options to any option you
would like.

@cindex Viewing code
Alternatively, if you aren't too faimilar with Emacs (in which case we
strongly recommend to become familiar with it!) or you just want a
fast preview, Github provides an exellent framework. Go to
@url{https://github.com/makhlaghi/mockgals, MockGals page on Github}
and click on any directory (with the shape of a folder) or source code
file to see the contents of that directory or file. Github tries to do
a good job in color coding the coding grammer of the program, which is
good for a fast online check of a section of the code. Emacs is
fabulous at this job!





@node Program flow,  , Reading method, How it works
@section Program flow and functions

@findex main
@findex mockimg
@findex SRC/ui.c
@findex SRC/mock.c
As in any C/C++ program, @code{main()} is the place to start reading
MockGals, you can find this function defined in
@file{SRC/main.c}. In MockGals, @code{main()} is just a connector
between two main types of functions: the ones that read the user input
and set the default values that are defined in @file{SRC/ui.c} and
the one that actually makes the mock image: @code{mockimg()} based on
those input values. @code{mockimg()} is defined in
@file{SRC/mock.c}.

@menu
* Defining settings::           Reading input or setting the default values.
* 2D arrays::                   2D arrays in MockGals(in C).
* C and FITS arrays::           FITS and C difference in array indexing.
* Making the canvas::           Array to build the galaxies on.
* Making the profiles::         How MockGals builds each profile.
@end menu





@node Defining settings, 2D arrays, Program flow, Program flow
@subsection Reading input or setting default values
The functions in @file{SRC/ui.c} are very simple functions that can
easily be understood. All of MockGals' parameters are stored as
variables in the @code{mockparams} structure that is defined in
@file{SRC/mock.h}. This is why the pointer to this structure is the
input to all the functions in @file{SRC/ui.c}, where they fill it up.

Once all the paramters are set and the program enters
@code{mockimg()}, which you can find in @file{SRC/mock.c}, the
exciting part begins. First the PSF is either made or read
from a FITS file in the function @code{readormakepsf()}, this function
also checks for the sides of the input PSF FITS image to be odd
numbers and also makes sure that the sum of the PSF is unity.  If the
PSF image is also of any other type than a @code{float}, this function
will make sure that the array that goes into the MockGals is a float.





@node 2D arrays, C and FITS arrays, Defining settings, Program flow
@subsection 2D arrays in C
@cindex 2D arrays
@cindex Arrays, 2D
@cindex Arrays, 1D
@cindex Array indexing, 1D
Before continuing it is important to mention a very important fact
about 2D arrays. A 2D array or matrix is a structure composed of a
certain number of columns and rows, forming a rectangle. It is
customary to label the elements on an array with a pair
@mymath{(x,y)}, where the first number specifies the row number of
that element and the second specifies its column number.

@cindex 1D array as 2D interpretation
@cindex Interpreting 1D array as 2D
In C, an array is a contiguous set of elements, in whatever data type,
like @code{int} or @code{float}, that you are using. This generic 1D
array can easily be interpreted as a 2D (or any number of dimensions)
array. To do that, it must be possible for its length, or the number
of its elements, to be written as @mymath{a\times b} where @mymath{a}
& @mymath{b} are both integers. In C the @code{i}th element of an
array @code{A} is denoted by @code{A[i]} and counting begins from
zero.

@cindex 2D Array indexing
@cindex Array indexing, 2D
The first element of any array has index (0,0) in this 2D illusion of
a real 1D array. The second element is located at (0,1).  The third,
on the third column of the first row (0,2) and so on. Taking
@mymath{b} as the number of columns in the 2D array, then the element
with index @mymath{b} of the 1D array can be interpreted as being the
first element of the second row at (1,0). In this fashion, we can
easily find the element at (x, y) on our hypothetical 2D array by
finding element number @mymath{x\times b+y} on the real 1D
array. Recall that we took @mymath{b} to represent the number of
columns in the hypothetical 2D array.

To see the value of the (@code{x},@code{y}) element on the 2D illusion
we just have to call @code{a[x*b+y]}. Also, supposing a 1D index of
@code{i} (where @code{i} is not a floating point type), we can find
the 2D coordinates with: @code{x=i/b} and @code{y=i%b}, where @code{%}
is the remainder or modulus and @code{/} is integer division where for
example @code{5/2=2}.

There are methods to use an array of pointers to point to the starting
positions of each row in a C array and thus work on that array of
pointers to create a better abstraction of a 2D array. The
advantage is that you can easily call element (x, y) with
@code{a[x][y]}.

This level of abstraction is not without its costs. First of all you
have to allocate another array of pointers the size of the number of
rows in the image. Pointers are 8 bytes or 64 bits on most current
systems and thus much larger than an @code{int} or @code{float} which
are usually only 4 bytes. This only applies to all PL64 based
operating systems like Linux of course. Therefore this level of
abstraction will take more memory on your system, especially if your
images become large or numerous. Also, we have to consider that the C
compiler actually sees @code{a[x][y]} as @code{*(*(a+i)+j)}, where
@code{*} is the dereference operator, not a multiple
operator. Therefore we see that calling element (x,y) as
@code{a[x][y]} is both more CPU and memory intensive than calling it
with @code{a[x*b+y]}.

Another useful aspect of acknowledging that we actually have a 1D
array is when we want to just go over all of the elements. For example
to calculate the sum of all the elements. In such cases we can totally
ignore the 2D assumption and work as if we were working on a 1D array
(define one looping paramter, not two), see the loop in @ref{making
binary image example}, this will result in a faster, less buggy and
cleaner code.

Based on these arguments, in MockGals we always find pixel (@code{x},
@code{y}) on an array (lets name it @code{a}) which consider as having
@code{b} columns with @code{a[x*b+y]}.





@node C and FITS arrays, Making the canvas, 2D arrays, Program flow
@subsection C and FITS array indexing
@cindex Array indexing, C and FITS
@cindex C and FITS array indexing
@cindex FITS and C array indexing
Until now we were only considering arrays as defined in C and other
languages that are based on it for example C++, Java, Python,
etc. Unfortunately, the FITS standard is defined based on Fortran,
which has two major differences with C that make a difference when we
want to use the values from the FITS headers or when we want to
interpret the FITS positions. The two major differences are:

@cindex FITS array indexing
@itemize
@item 
Counting begins from 1 not 0.

@item
The second element of the 1D array is interpreted as being on (1,0) in
the 2D illusion. Recall that in C, this same element was consdiered to
be positioned at (0,1).
@end itemize

@cindex Converting C to FITS indexing
@cindex Array indexing, converting C to FITS
So in general a point positioned at @mymath{(x,y)} in a FITS image is
positioned at @mymath{(y-1,x-1)} in the C array. Also the FITS header
keyword @env{NAXIS1} is actually the number of columns in C and
@env{NAXIS2} is the number of rows. One place to see this difference
is in the ds9 FITS viewer. Of course, MockGals was designed to
completely hide this for the outside user such that the inputs and
outputs are all done in the FITS standard. On ds9, the first element
of the array is the bottom left pixel.

This difference in definition also requires another conversion when
reading mock galaxy properties: the position angle (@mymath{\theta}),
see @ref{Defining an ellipse}. Based on our definition there, it is
the angle with the first axis of the array, which is different between
the two standards. The equation to convert the two is:

@dispmath{\theta_{\rm{C}}=90^\circ-\theta_{\rm{FITS}}}

@pindex fitsarrayvv
In order to read from and write to a FITS image with relative ease we
have written a very simple library so that only by calling one
function, the pixels of one FITS image will be saved into a C array
and vice versa. It is @url{https://github.com/makhlaghi/fitsarrayvv,
available on Github} and can be considered as a wrapper for CFITSIO,
which does the main job! It can easily be incorporated into any
program. In MockGals we are using this program to interact with a FITS
image.





@node Making the canvas, Making the profiles, C and FITS arrays, Program flow
@subsection Making the canvas

All the input parameters, possible input table and PSF have been read,
now we are in @code{mockimg()} (@file{SRC/mock.c}) and the first thing
we have to do is making the canvas (the array that will hold the final
pixel values).

It might seem to be an easy job: just allocate (with @code{calloc()}
ofcourse to make a white and clean canvas) an array the size of the
desired image. But unfortunately things aren't that simple! This is
because after we have made all the profiles, we have to convolve the
image with the PSF and the standard tool to do that has an unwanted
consequence that we should take into account, see @ref{DFTdemo}. If we
ignore this very serious consequence of our convolution method, the
galaxies or the parts of galaxies that lie on the edges of the images
will be affected.

@pindex FFTW
@cindex Discrete fourier transform
@cindex DFT
The image is convolved with the PSF using the
@url{http://www.fftw.org/, FFTW3} package. It provides some functions
to do very fast and accurate convolutions using discrete fourier
transform (DFT) on the image and the Kernel which is the array keeping
the PSF in our case. The basic concept behind DFT is very interesting
and is far beyond the scope of this short manual. The book Digital
Image Processing by Gonzalez and Woods gives a very nice introductory
overview of the basic concept behind this facinating application of
the fourier transform concept in a descrete space.

@cindex DFT, blurring sides
@cindex Blurring sides, DFT
The most important consequence of DFT is that the sides of the image
will not be correctly blurred. To demonstrate this, we manually
changed half of the pixel values in an input image to MockGals to 0
and the other half to 1 by adding the following simple loop just after
making the mock galaxies (only for this example of course!). By
placing the following code right after the loop that makes the
profiles one by one in @code{mockimg()}.

@anchor{making binary image example}
@example
/********************************************************************/
for(i=0;i<nsize;i++)      /*'nsize': number of elements in 'img[]'. */
  img[i]=i>nsize/2;       /* 1 if true, 0 if flase. */

array_to_fits("tmp.fits", NULL, "NOCONV", FLOAT_IMG, img, ns0, ns1);  
/********************************************************************/
@end example

@noindent
@code{array_to_fits()} is defined in @file{SRC/fitsarrayvv.c}.
We show things like this to encourage you to play with the code and
change it so you can learn the code better. This is the whole purpose
that the source code is free, so you can read it, modify it, learn
from it and finally correct it. 

This changing of values makes all the trouble of making 45 mock
profiles go to absolute waste! But it is just for a temporary
demonstration, so we won't change too much of the code! One note of
caution if you do attempt to make temporary changes in any code like
this: put some large segments of commented notes (like this example)
around the code you have added temporarily to clearly mark them. In
more complicated cases, you might forget to remove one line after a
test and it might take hours to find it again! In future examples we
will not put these lines in example pieces of code.

The resulting array (after turning it to a binary image) before
convolution can be seen on the left of @ref{DFTdemo}. To save the
convolved image, we just run the @code{array_to_fits()} line, after
calling @code{convolve()} (which is defined in
@file{SRC/convolve.c}).

@float Figure, DFTdemo
@center@image{./mockgals-figures/s7_dft1,5cm,,./mockgals-figures/s7_dft1.jpg,.jpg}@image{./mockgals-figures/s7_dft2, 5cm,,./mockgals-figures/s7_dft2.jpg,.jpg}

@caption{Left: A binary image, with half of the pixels being zero
(black), the other half 1 (white). The kernel used to convolve is the
same PSF as @ref{quickpreview}. Note how after convolution through
DFT, the borders of the white region become dark.}
@end float

We see from this example that due to the nature of DFT, the sides will
become darker than they should. The number of pixels that become
darker on the sides is half the size of the PSF, so if the PSF is a
box of 15 pixels width, 7 pixels of each side will become darker. To
correct this defect the canvas we allocate to build the galaxy image
on is larger by than the actual desired output image by the same size,
namely, haf the PSF width, the new sizes are named @code{ns0} and
@code{ns1}. After convolving the image we @code{floatshrinkarray()} to
crop the central parts. with this correction we can be sure that the
mock galaxies on the edges of our image have the same brightess as
they would have after convolution of those in the center.





@node Making the profiles,  , Making the canvas, Program flow
@subsection Making the profiles

In order to be able to build the profiles most efficiently and most
accurately, the canvas is not the only thing we need. In MockGals we
have created a very simple Graph based approach to building the
profiles based on the nearest pixel in the image to the profile
center. Using the closest neighbors of that pixel and their neighbors
we can accurately and speedily find the pixels in the image that
require integration, see @ref{Central profile pixels}.

@menu
* Graph canvas::                Graph based canvas.
* Finding nearest pixel::       Nearest pixel to the profile center.
* Making central::              Making the central regions.
* Rest of profile::             How the rest of the profile is built.
@end menu





@node Graph canvas, Finding nearest pixel, Making the profiles, Making the profiles
@subsubsection Graph canvas

We want to build the profiles inside-out, in other words, we want to
begin building the profile from its central pixel or the pixel in the
image that is most nearest to it if the central pixel is out of the
image. See @ref{integpixfill} and @ref{restpixfill} for
demonstration. The reason we want to do this is because we want to
integrate over the central pixels where it is very important, and stop
integrating at a certain point beyond which there is no big difference
between integration and the central pixel value.

@cindex Graph theory
@cindex Bredth first search
So once we find the first pixel to start with (the pixel closest to
the center of the profile), we have to continuesly look around at its
neighbors, and the neighbors of those neighbors and so on, until we
can completely construct the profile. In this process we can stop
integrating when the difference between integration over the pixel
value and the central pixel value becomes smaller than a user defined
tollerance level. This type of searching is called
@url{http://en.wikipedia.org/wiki/Breadth-first_search, Breadth first
search} in graph theory.

@cindex Pixel neighbors, searching
@cindex Searching for pixel neighbors
But doing this search without knowning the neighbors of a pixel before
hand is very hard! For every pixel you have to search for all the
neighbors and for each potential neighbor, you have to check if it is
lying outside the image boundaries or not! This many checks for each
pixel, is going to take a lot of our CPU's power, especially if you
want to do this over a large number of pixels for a large object. In
effect, it will slow down the program.

By looking at the image as a graph, we define the neighbors and the
relation of the neighbors to each pixel before working on the image,
in one pass. Then in future passes, since the neighbors of all the
pixels are already defined, we just go through them, not worrying
about how many of them lie in the image. In image processing we have
two types of connectivity (neighbors): four and eight. Generally we
also want to have the ability to distinguish between such neighbors,
so in some applications we can only look at the 4 connected neighbors
and in others at the 8 connected neighbors.

@cindex 4 connectivity
@cindex Four connectivity
@cindex Connectivity, four
@cindex 8 connectivity
@cindex Eight connectivity
@cindex Connectivity, eight
A pixel is four connected to another if it touches the pixel on its
sides. Therefore a pixel located at (@code{x},@code{y}) is four
connected to the four pixels at (@code{x-1},@code{y}),
(@code{x+1},@code{y}), (@code{x},@code{y-1}) and
(@code{x},@code{y+1}). Adding these last four with the four pixels
that are diagonally connected or (@code{x-1},@code{y-1}),
(@code{x-1},@code{y+1}), (@code{x+1},@code{y-1}) and
(@code{x+1},@code{y+1}), we get to the 8 connected pixels.

@cindex Neighbors array, @code{ngbs[]}
@cindex ngbs[], Neighbors array
@findex NGBSCOLS
The way we propose to achieve this goal is through a simple array
keeping the positions of the neighbors for each pixel, lets call it
@code{ngbs[]}.  Assuming the image has @code{s0} rows and @code{s1}
columns, then @code{ngbs[]} will have @code{s0*s1*NGBSCOLS} elements,
@code{NGBSCOLS} is explained below. @code{ngbs[]} is defined to be
@code{size_t}, which can be thought of as @code{unsigned long} (8
bytes on 64 bit machines).

@findex NONINDEX
@findex Impossible index
@cindex Strings in C
For each pixel in the image we have a row of @code{NGBSCOLS}
columns. Column 1 until and including column 8 will contain the
indexes of the maximum 8 possible neighbors. If there are less
neighbors, we put a @code{NONINDEX=(size_t)(-1)=18446744073709551615}
(on 64bit machines) after the last neighbor. This makes our neighbor
searching tool very similar to how C defines strings (which end with
the impossible @code{NUL} or @code{\0} character). In our case, the
impossible value is @code{NONINDEX}. Since any 4 connected neighbor is
also an 8-connected neighbor, first the indices of the 8-connected
neighbors are placed in these columns, and then the 4-connected
neighbors. Column 0 keeps the index of the column where the four
connected neighbors begin. The last column is reserved for those
pixels that have all 8 neighbors and will use this to keep
@code{NONINDEX}. Therefore @code{NGBSCOLS=1+8+1=10}.

@cindex Finding neighbors
In this fashion, if we want the 8 connected neighbors of a pixel
located at (@code{x},@code{y}), which has index @code{i=x*s1+y}, then
a simple loop like the following will do the job:

@example
numngb=1;
printf("%lu: ", i);
do 
  printf("%lu, ", ngbs[i*NGBSCOLS+numngb]);
while(ngbs[i*NGBSCOLS+ ++numngb]!=NONINDEX); 
printf("\b\b.\n");
@end example

If we want the list of 4 connected indexes to that pixel, we can
simply change the first line to @code{numngb=n[i*NGBSCOLS];}.  As an
example, assuming we have @code{s0=4} and @code{s1=4}, then the list
of four and eight connected neighbors can easily be printed as below
(by placing the code above in a loop over all the pixels). Note that
we only need the indexes of each pixel in the actual array, we don't
need the row and column number of each pixel. In the table below, the
number before the colon (@code{:}) is the index of the pixel in
question.

@example
--------------------------------------------------------------
      8-connected neighbors       | 4-connected neighbors
--------------------------------------------------------------
0: 5, 1, 4.                       |    0: 1, 4.
1: 6, 4, 2, 0, 5.                 |    1: 2, 0, 5.
2: 7, 5, 3, 1, 6.                 |    2: 3, 1, 6.
3: 6, 2, 7.                       |    3: 2, 7.
4: 1, 9, 5, 8, 0.                 |    4: 5, 8, 0.
5: 0, 2, 8, 10, 6, 4, 9, 1.       |    5: 6, 4, 9, 1.
6: 1, 3, 9, 11, 7, 5, 10, 2.      |    6: 7, 5, 10, 2.
7: 2, 10, 6, 11, 3.               |    7: 6, 11, 3.
8: 5, 13, 9, 12, 4.               |    8: 9, 12, 4.
9: 4, 6, 12, 14, 10, 8, 13, 5.    |    9: 10, 8, 13, 5.
10: 5, 7, 13, 15, 11, 9, 14, 6.   |    10: 11, 9, 14, 6.
11: 6, 14, 10, 15, 7.             |    11: 10, 15, 7.
12: 9, 13, 8.                     |    12: 13, 8.
13: 10, 8, 14, 12, 9.             |    13: 14, 12, 9.
14: 11, 9, 15, 13, 10.            |    14: 15, 13, 10.
15: 10, 14, 11.                   |    15: 14, 11.
@end example

@findex imgngbs
@findex SRC/pix.c
@noindent
In MockGals, @code{ngbs[]} is made and filled in the @code{imgngbs()}
function which is defined in @code{SRC/pix.c}. @code{imgngbs()} does
this job without any conditionals in the loops, thus it is very
efficient. With an infra structure like this, we can go through all
the neighbors of all the pixels or even all the neighbors of the
neighbors, very fast, without worrying about how many neighbors of
each pixel are in the image or what kind of connectivity we want, all
the necessary information is in this one array. The code to do a
breadth-first search with this structure can thus be very short and
thus less buggy, easier to read and last but not least, more CPU
efficent.





@node Finding nearest pixel, Making central, Graph canvas, Making the profiles
@subsubsection Finding the closest pixel to profile center
@cindex Nearest pixel to profile center
@cindex Profile center, nearest pixel
Now that the graph canvas is built, see @ref{Graph canvas}, building
the profiles is very easy. @code{mockimg()} (in @file{SRC/mock.c}) now
begins building the profiles one by one (through
@code{makeprofile()}). The first thing @code{makeprofile()} does is to
find the closest pixel in the image to the center of the profile. To
do that it calls @code{findstartingpixel()}. Which does the job based
on the input coordinates, axis ratio, position angle and truncation
radius.

@cindex Profile center out of image
@findex SRC/raddist.c
@cindex Finding ellipse extremes
@cindex Ellipse, finding extremes
If the center of the profile lies within the image boundaries, that
point, the pixel is returned as the starting pixel. If the center is
outside of the image boundary, it finds the box that encloses the
profile ellipse within the truncation radius. To find this box,
@code{findstartingpixel()} calls @code{encloseellipse()} which is
located in @file{SRC/raddist.c}. All the points on the circumference
of an ellipse that is aligned on the x axis can be written
parametrically as:

@dispmath{(a\cos(t),b\sin(t))\quad\rm{where}\quad t\in(0,2\pi)}

@cindex Rotating ellipse
@cindex Ellipse rotation
@noindent  
But when we rotate the ellipse by @mymath{\theta}, the points can be
characterized by:

@dispmath{(a\cos(t)\cos(\theta)+b\sin(t)\sin(\theta),-a\cos(t)\sin(\theta)+b\sin(t)\cos(\theta) )}

To find the maximum and minimum points of this function you just have
to take the derivative of each with respect to @mymath{t} and set it
to zero. This will give you the @mymath{t} that maximizes x and the
@mymath{t} that maximizes y.  Once you do that, you will get:

@dispmath{\rm{x:}\quad tan(t)=(b/a)tan(\theta)}
@dispmath{\rm{y:}\quad tan(t)=(-b/a)cot(\theta)}

Placing @mymath{t} it in the second equation above for the respective
coordinate, you will find the distance, about the center of the
ellipse that encloses the whole ellipse. This defines a box for us
that will enclose the whole ellipse. @code{findstartingpixel()} then
checks for a possible overlap of this box with the image and if it
exists, finds the pixel on the border of the image that is closest to
the center of the profile and returns that point.





@node Making central, Rest of profile, Finding nearest pixel, Making the profiles
@subsubsection Building profile center
The pixel in the image nearest to the profile center has been found,
see @ref{Finding nearest pixel}. As discussed in @ref{Central profile
pixels}, if the center of the profile is in the image, accurately
modeling the central parts of a sharp galaxy is very tricky and simply
using the pixel center value is inaccurate. Until an initially unknown
radius, we have to find the average value of a large number of
randomly positioned points within a pixel. Beyond that we can
integrate over the pixel area and finally, once the tolerance is
passed, we can use the central pixel value.

So two radii have to be found. The best way to avoid any systematic
bias is finding them in practice, while building the
profile. Fortuantely we are begining from the nearest pixel to the
center of the profile, we just have to make sure that the pixel that
is checked after that is the nearest of all the neighbors. This
process has to continue, such that we can go through the pixels of the
profile based on their elliptical distance, see @ref{Defining an
ellipse}. 

@findex SRC/sll.h
@cindex Ordered queue (simple linked list)
@cindex Queue, ordered
@cindex Simple linked list, ordered
So our goal is to go through the pixels based on increasing
@mymath{r_{el}}. In order to be able to do this in a very fast manner,
we define a two sided (or double ended) ordered queue (simple linked
list). The nodes in this ordered queue are defined in @file{SRC/sll.h}
as:

@example
struct tossll
@{
  size_t v;                     /* Pixel index.              */
  float s;                      /* Elliptical radius.        */
  struct tossll *prev;          /* Pointer to previous node. */
  struct tossll *next;          /* Pointer to next node.     */
@};
@end example

@noindent
A pixel (a node in the queue) is added to this ordered queue with
@code{add_to_tossll_end()}. The new node is positioned in the queue
such that its next element has a smaller @mymath{r_{el}}. In this
fashion, the top (ending) node always has the largest @mymath{r_{el}}
and the bottom (starting) node has the smallest @mymath{r_{el}}. Since
the new nodes comming into the queue generally have larger
@mymath{r_{el}}, this structure enables us to save a lot of CPU
energy.

We pop out the starting node, that has the smallest @mymath{r_{el}},
with @code{pop_from_tossll_start()}. The first pixel to go into this
queue is the central pixel found before, see @ref{Finding nearest
pixel}. We then enter a loop and until the given tolerance is reached,
see @ref{Central profile pixels}, a pixel (which has the smallest
@mymath{r_{el}}) is popped from the queue and if it has not already
been filled, the following steps are applied to it:

@enumerate
@item
The profile is integrated over that pixel's surface and added
to the image. 
@item
The 8-connected neighbors to that pixel which have not already been
filled are added to the ordered queue.
@end enumerate

@cindex Gauss-Kronrod-Patterson abscissae
@cindex Integration, method
Integration is done with the GNU Scientific Library (GSL) function
@code{gsl\_integration\_qng()} which, according to the manual is a
non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson
abscissae to sample the integrand at a maximum of 87 points, it is
provided for fast integration of smooth functions.

@cindex Filling central profile
@cindex Profile, filling center
@ref{integpixfill} shows how the process just explained is applied in
practice. In this figure the mock profile of @ref{pixintegq25} with
@mymath{n=4}, @mymath{r_e=3}, @mymath{\theta=60^\circ} and
@mymath{q=0.25} is filled in the center of a small box. It clearly
demonstrates how the pixels with the smallest radius are found and
filled in order. The first two pixels of those demonstrated here are
filled with @mymath{10^4} random points, integration is applied to the
rest. The relative difference, see @ref{Central profile pixels},
between random points and integration for the central pixel is
@mymath{1.17}. For the second pixel, this difference becomes
@mymath{0.00023}. Therefore beyond the second pixel, integration is
simply used.

@float Figure, integpixfill
@center@image{./mockgals-figures/s7_integpixfill,15cm,,./mockgals-figures/s7_integpixfill.gif,.gif}

@caption{Demonstration of how the first 24 pixels of @ref{pixintegq25}
which require integration are found in order or increasing elliptical
radius. The complete profile can be seen as the last frame in
@ref{restpixfill}. The pixels are colored based on the logarithm of
their flux and truncated, such that the central regions are completely
black, to easily demonstrate the pixels used. The complete profile can
be seen in restpixfill. }
@end float





@node Rest of profile,  , Making central, Making the profiles
@subsubsection Filling profile surface
@cindex LIFO
@cindex Last in, first out queue
@cindex Queue, last in, first out
Integration has been accomplished for those pixels that required it,
see @ref{Making central}. The rest of the job is very easy, a
simple ``last in first out'' (LIFO) queue (linked list) is defined as
below to keep the pixels that belong to this profile. 

@example
struct ssll
@{
    size_t v;
    struct ssll *next;
@};
@end example

@noindent
First the remaining pixels from the ordered queue of @ref{Making
central} are added to this queue. The last pixel that is put in the
queue is then popped from it and the following two steps will be
taken:

@enumerate
@item 
The profile value for the center of the pixel is found.
@item
If any of the pixel's four connected neighbors have not already been
calculated, they are added to the queue.
@end enumerate

@noindent
The distance of the pixels no longer matters, therefore we just define
4-connectivity to decrease the number of tests if the pixel has
already been done. @ref{restpixfill} demonstrates how the rest of the
pixels are filled for the same profile of
@ref{integpixfill}. @inlinefmtifelse{html, This GIF image to show all
the steps is 4.3 MB which might take some time to download if you have
a slow connection., The
@url{http://astr.tohoku.ac.jp/~akhlaghi/mockgals/mockgals/, HTML
version} of this manual has a GIF animation here showing the pixel by
pixel buildindg of the profile.}
@c the @inlinefmtifelse{} is a conditional line function, each comma
@c is significant for it, so don't add any commas to the two sentences
@c above.

@float Figure, restpixfill
@center@image{./mockgals-figures/s7_restpixfill,15cm,,./mockgals-figures/s7_restpixfill.gif,.gif}

@caption{Demonstration of filling the rest of the profile pixels, see
@ref{integpixfill}. Since the radial distance no longer matters,
pixels are just filled based on their position in the LIFO
queue. Since putting all the pixel levels was impossible in print,
only several stages of the steps are shown on the PDF version, in the
HTML format, a GIF animation of all the pixles is shown.}
@end float




















@node GNU General Public License, GNU Free Documentation License, How it works, Top
@appendix GNU General Public License
@include ./docsrc/gpl_v3.texi




















@node GNU Free Documentation License, Manual Index, GNU General Public License, Top
@appendix GNU Free Documentation License
@include ./docsrc/fdl.texi




















@node Manual Index,  , GNU Free Documentation License, Top
@unnumbered Index




















@printindex cp

@bye
